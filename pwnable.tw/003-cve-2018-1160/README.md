# CVE-2018-1160 - Netatalk RCE

## Challenge Info

| Property | Value |
|----------|-------|
| Platform | pwnable.tw |
| Points | 100 |
| Category | PWN |
| Target | `nc chall.pwnable.tw 10002` |

## Overview

This challenge requires developing a 1-day exploit for CVE-2018-1160, a critical vulnerability in Netatalk (Apple Filing Protocol server) versions before 3.1.12.

## Files Provided

- `netatalk.tgz` - Contains `afpd` binary and `libatalk.so.18`
- `libc.so` - Target libc (`libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so`)

## Binary Protections

```
afpd:           Full RELRO, Canary, NX, PIE enabled
libatalk.so.18: Partial RELRO, Canary, NX, PIE
libc.so:        Partial RELRO, Canary, NX, PIE
```

## Vulnerability Analysis

### CVE-2018-1160: Out-of-Bounds Write in dsi_opensess.c

Netatalk's DSI (Data Stream Interface) layer handles AFP protocol communication. The vulnerability exists in `dsi_opensession()` function in `libatalk/dsi/dsi_opensess.c`.

#### Root Cause

When processing DSI OpenSession options, there's no bounds check on the option data length. The `DSIOPT_ATTNQUANT` option handler copies user-controlled data without validating the size:

```c
// Vulnerable code pattern
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, p + 2, opt_length);  // No size check!
    break;
```

#### Overflow Impact

With an oversized option, we can overflow into adjacent DSI struct fields:

```
Offset  Field           Size    Description
--------------------------------------------------
+0x00   attn_quantum    4       Attention quantum
+0x04   datasize        4       Data size
+0x08   server_quantum  4       Server quantum (reflected!)
+0x0c   serverID        2       Server ID
+0x0e   clientID        2       Client ID
+0x10   commands        8       Pointer to DSI receive buffer
+0x18   data            ...     Data buffer
```

The critical field is `commands` - a pointer to the buffer where subsequent DSI packets are written.

## Exploitation Strategy

### 1. ASLR/PIE Bypass via Memory Oracle

Since the server uses `fork()` for each client connection:
- All child processes share the same memory layout as the parent
- Invalid address write causes child crash (connection drops)
- Valid address write allows the session to continue

This enables byte-by-byte address brute-forcing:
- Test each byte value (0x00-0xFF)
- Connection survived = valid byte
- Maximum ~768 attempts (256 × 3 bytes) to leak full address

### 2. Arbitrary Write via Commands Pointer

After overwriting `commands` to point to a target location:
- Next DSI packet data is written to our controlled address
- We can write `one_gadget`/`system` address to `__free_hook`

### 3. Trigger RCE via dsi_close

Sending DSI CloseSession triggers `free()` on internal buffers:
- `__free_hook` is called with our one_gadget
- Spawns shell

## Key Offsets

### Libc Offsets

```python
LIBC_FREE_HOOK = 0x3ed8e8
LIBC_SYSTEM    = 0x4f440
LIBC_BINSH     = 0x1b3e9a
LIBC_EXECVE    = 0xe4e30

ONE_GADGETS = [0x4f2c5, 0x4f322, 0x10a38c]
```

## DSI Protocol

DSI Header (16 bytes):
```
+0x00: flags         (1 byte)  - 0x00=request, 0x01=reply
+0x01: command       (1 byte)  - DSI command code
+0x02: request_id    (2 bytes) - Request identifier
+0x04: error/offset  (4 bytes) - Error code or data offset
+0x08: length        (4 bytes) - Total data length
+0x0c: reserved      (4 bytes) - Reserved
```

DSI Commands:
```
DSI_CLOSESESSION = 0x01
DSI_COMMAND      = 0x02  (AFP wrapper)
DSI_GETSTATUS    = 0x03
DSI_OPENSESSION  = 0x04
DSI_TICKLE       = 0x05
```

## Exploit Flow

```
1. Connect to target (port 10002)

2. Leak libc address (byte-by-byte oracle):
   - For each byte position (0-5):
     - For each value (0x00-0xFF):
       - Send overflow with test address
       - If response received: byte found
       - If connection drops: try next value

3. Calculate addresses:
   - libc_base = leaked_addr - known_offset
   - free_hook = libc_base + 0x3ed8e8
   - one_gadget = libc_base + 0x4f2c5

4. Overflow commands pointer:
   - Send OpenSession with overflow payload
   - Set commands = free_hook - 0x10

5. Write one_gadget to __free_hook:
   - Send DSI Command with gadget address
   - Data written to redirected commands location

6. Trigger RCE:
   - Send DSI CloseSession
   - free() calls __free_hook
   - one_gadget executes → shell
```

## Running the Exploit

```bash
# Full exploit (auto brute force + RCE)
python3 exploit.py

# Direct exploit with known libc base
python3 exploit.py 0x7f1234560000

# Local testing
python3 exploit.py local
```

## Current Status

The exploit successfully:
1. Leaks heap/libc addresses via byte-by-byte oracle (~768 attempts max)
2. Calculates libc base from leaked address
3. Overflows commands pointer to __free_hook
4. Writes one_gadget/system address to __free_hook

**Issue**: The one_gadgets don't spawn a shell due to unsatisfied constraints:
- 0x4F2C5: requires `rsp+0x40 == NULL`
- 0x4F322: requires `rsp+0x40 == NULL`
- 0x10A38C: requires `rsp+0x70 == NULL`

When `__free_hook` is invoked via `free(ptr)`:
- rdi = ptr (the pointer being freed)
- The stack doesn't satisfy one_gadget constraints

**Potential Solutions**:
1. Find a stack pivot gadget to control stack contents
2. Target GOT entries in libatalk (Partial RELRO) instead of libc hooks
3. Use the Tenable approach: overwrite preauth_switch for file access
4. Find alternative gadgets that don't have stack constraints

## Challenge Hints

The challenge mentions:
> "Kernel version may be changed after the environment updated. You can get the current version from the other challenge."

This suggests leveraging information from another pwnable.tw challenge to determine the exact libc base or kernel randomization seed.

## References

- [CVE-2018-1160 Official Advisory](https://netatalk.io/security/CVE-2018-1160)
- [Tenable Research - Exploiting an 18 Year Old Bug](https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172)
- [Tenable PoC - pea.py](https://github.com/tenable/poc/tree/master/netatalk/cve_2018_1160)
- [shxdow - CVE-2018-1160 Writeup](https://shxdow.me/cve-2018-1160/)
- [NVD - CVE-2018-1160](https://nvd.nist.gov/vuln/detail/CVE-2018-1160)

## Timeline

- **2018-12-20**: Vulnerability disclosed by Jacob Baines (Tenable)
- **2018-12-20**: Netatalk 3.1.12 released with fix
- **Commits**: 6725632, b6895be
